import React, { useState, useRef, useEffect, useCallback, useLayoutEffect } from 'react';
import { useParams } from 'react-router-dom';
import { supabase } from '../lib/supabase';
import { format } from 'date-fns';
import { fr } from 'date-fns/locale';
import UnifiedTrainingAgreementTemplate from './shared/templates/unified/TrainingAgreementTemplate';
import SignatureCanvas from './SignatureCanvas';
import { createPortal } from 'react-dom';
import { X, Download, CheckCircle } from 'lucide-react';
import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';
// @ts-ignore
import html2pdf from 'html2pdf.js';
import { createRoot } from 'react-dom/client';
import { DocumentManager } from './shared/DocumentManager';
import { toast } from 'react-hot-toast';
// @ts-ignore
import { Helmet } from 'react-helmet';
// @ts-ignore
import Confetti from 'react-confetti';
// @ts-ignore
import { BeatLoader } from 'react-spinners';
import { optimizeSealUrl } from '../utils/SignatureUtils';
import { OrganizationSettings } from './shared/DocumentUtils';

// Types
interface Company {
  id?: string;
  name: string;
  address?: string;
  postal_code?: string;
  city?: string;
  siret?: string;
  contact_name?: string;
  contact_email?: string;
  contact_phone?: string;
  isIndependent?: boolean;
}

// Dans la section des types, d'abord ajouter une d√©finition de type pour les participants
interface ParticipantData {
  id: string;
  first_name: string;
  last_name: string;
  job_position?: string;
  company?: string;
  email?: string;
  status?: string;
}

// Fonction utilitaire pour parser un champ JSON qui pourrait √™tre doublement √©chapp√©
const parseJsonField = (field: any) => {
  if (!field) return null;
  
  // Si c'est d√©j√† un objet, le retourner tel quel
  if (typeof field === 'object') return field;
  
  // Si c'est une cha√Æne, essayer de la parser comme JSON
  if (typeof field === 'string') {
    try {
      // G√©rer le cas o√π le JSON est doublement √©chapp√© (comme dans tracking_methods)
      if (field.startsWith('"') && field.endsWith('"')) {
        // Supprimer les guillemets externes et parser le contenu
        const unescapedField = field.substring(1, field.length - 1).replace(/\\"/g, '"');
        return JSON.parse(unescapedField);
      }
      
      // Parser directement si c'est un format JSON standard
      return JSON.parse(field);
    } catch (e) {
      console.error('Erreur lors du parsing JSON:', e, 'field:', field);
      return null;
    }
  }
  
  return null;
};

// D√©finition des param√®tres par d√©faut pour l'organisation
const DEFAULT_ORGANIZATION_SETTINGS: OrganizationSettings = {
  organization_name: 'PETITMAKER',
  address: '2 rue H√©racl√®s',
  siret: '928 386 044 00012',
  activity_declaration_number: '32 59 10753 59',
  representative_name: 'Nicolas Cleton',
  representative_title: 'Pr√©sident',
  city: 'Villeneuve-d\'Ascq',
  postal_code: '59650',
  country: 'France'
};

// Fonction utilitaire de log
const log = (emoji: string, type: string, message: string, data?: any) => {
  if (data) {
    console.log(`${emoji} ${type}`, message, data);
  } else {
    console.log(`${emoji} ${type}`, message);
  }
};

// Interface pour le cache global de signatures
interface SignatureCacheItem {
  participantSig?: string | null;
  companySeal?: string | null;
  organizationSeal?: string | null;
  trainerSig?: string | null;
  timestamp?: number;
}

// Cache global des signatures
const GLOBAL_SIGNATURE_CACHE = {
  cache: {} as Record<string, Record<string, SignatureCacheItem>>,
  
  getCache(trainingId: string, participantId: string): SignatureCacheItem {
    if (!this.cache[trainingId]) {
      this.cache[trainingId] = {};
    }
    return this.cache[trainingId][participantId] || {};
  },
  
  setCache(trainingId: string, participantId: string, data: SignatureCacheItem): void {
    if (!this.cache[trainingId]) {
      this.cache[trainingId] = {};
    }
    const currentData = this.cache[trainingId][participantId] || {};
    this.cache[trainingId][participantId] = {
      ...currentData,
      ...data,
      timestamp: Date.now()
    };
  },
  
  preloadImages(urls: (string | null | undefined)[]): void {
    urls.filter(Boolean).forEach(url => {
      if (url) {
        const img = new Image();
        img.src = url;
      }
    });
  }
};

// Fonction utilitaire pour charger les signatures de fa√ßon synchrone
function loadSignaturesSync(trainingId: string, participantId: string): SignatureCacheItem {
  try {
    console.log('‚ö° [INIT] Chargement synchrone des signatures:', { trainingId, participantId });
    
    // R√©cup√©rer depuis le cache local
    const cached = GLOBAL_SIGNATURE_CACHE.getCache(trainingId, participantId);
    console.log('üìã [INIT] Donn√©es du cache:', cached);
    
    // V√©rifier √©galement dans le localStorage pour plus de robustesse
    try {
      const localStorageKey = `signatures_cache_${trainingId}_${participantId}`;
      const storedData = localStorage.getItem(localStorageKey);
      
      if (storedData) {
        const parsedData = JSON.parse(storedData);
        console.log('üìã [INIT] Donn√©es du localStorage:', parsedData);
        
        // Si le cache en m√©moire est vide mais qu'on a des donn√©es dans le localStorage
        if (!cached.participantSig && !cached.companySeal && 
            (parsedData.participantSig || parsedData.companySeal)) {
          // Mettre √† jour le cache en m√©moire avec les donn√©es du localStorage
          GLOBAL_SIGNATURE_CACHE.setCache(trainingId, participantId, parsedData);
          console.log('üîÑ [INIT] Cache en m√©moire mis √† jour depuis localStorage');
          
          // Retourner les donn√©es du localStorage
          return parsedData;
        }
      }
    } catch (e) {
      console.error('‚ùå [INIT] Erreur lors de la r√©cup√©ration depuis localStorage:', e);
    }
    
    // Pr√©charger les images si disponibles
    if (cached.participantSig || cached.companySeal || cached.organizationSeal) {
      console.log('üîÑ [INIT] Pr√©chargement des images du cache');
      GLOBAL_SIGNATURE_CACHE.preloadImages([
        cached.participantSig, 
        cached.companySeal,
        cached.organizationSeal
      ]);
    }
    
    return cached;
  } catch (e) {
    console.error('‚ùå [INIT] Erreur du chargement synchrone des signatures:', e);
    return { participantSig: null, companySeal: null, organizationSeal: null };
  }
}

interface StudentTrainingAgreementProps {
  training: {
    id: string;
    title: string;
    duration: string;
    trainer_name: string;
    trainer_id?: string;
    location: string;
    start_date: string | null;
    end_date: string | null;
    objectives?: string[];
    content?: string;
    price?: number | null;
    company_id?: string;
    evaluation_methods?: {
      profile_evaluation?: boolean;
      skills_evaluation?: boolean;
      knowledge_evaluation?: boolean;
      satisfaction_survey?: boolean;
    };
    tracking_methods?: {
      attendance_sheet?: boolean;
      completion_certificate?: boolean;
    };
    pedagogical_methods?: {
      needs_evaluation?: boolean;
      theoretical_content?: boolean;
      practical_exercises?: boolean;
      case_studies?: boolean;
      experience_sharing?: boolean;
      digital_support?: boolean;
    };
    material_elements?: {
      computer_provided?: boolean;
      pedagogical_material?: boolean;
      digital_support_provided?: boolean;
    };
  };
  participant: {
    id: string;
    first_name: string;
    last_name: string;
    job_position?: string;
    company?: string;
    has_signed_agreement?: boolean;
  };
  onCancel: () => void;
  onDocumentOpen?: () => void;
  onDocumentClose?: () => void;
}

export const StudentTrainingAgreement: React.FC<StudentTrainingAgreementProps> = ({
  training,
  participant,
  onCancel,
  onDocumentOpen,
  onDocumentClose
}) => {
  const [company, setCompany] = useState<Company | null>(null);
  const [organizationSettings, setOrganizationSettings] = useState<OrganizationSettings | null>(null);
  const [showSignatureCanvas, setShowSignatureCanvas] = useState(false);
  const [showSealCanvas, setShowSealCanvas] = useState(false);
  const [participantSignature, setParticipantSignature] = useState<string | null>(null);
  const [representativeSignature, setRepresentativeSignature] = useState<string | null>(null);
  const [trainerSignature, setTrainerSignature] = useState<string | null>(null);
  const [companySeal, setCompanySeal] = useState<string | null>(null);
  const [organizationSeal, setOrganizationSeal] = useState<string | null>(null);
  const [generatingPDF, setGeneratingPDF] = useState(false);
  const [saved, setSaved] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);
  const [showError, setShowError] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');
  const [signatureInProgress, setSignatureInProgress] = useState(false);
  const [sealsVerified, setSealsVerified] = useState(false);
  const [isSigned, setIsSigned] = useState(false);
  const [isSaving, setIsSaving] = useState(false);

  // Ajouter un cache global d'images pour r√©duire les clignotements
  const PRELOADED_IMAGES: Record<string, boolean> = {};

  // √âtat pour stocker tous les apprenants li√©s √† la formation
  const [allTrainingParticipants, setAllTrainingParticipants] = useState<ParticipantData[]>([]);

  // Dans la partie des d√©clarations d'√©tat initiales (autour de la ligne 300)
  // Ajouter cette r√©f√©rence pour suivre la derni√®re fois que les signatures ont √©t√© charg√©es
  const lastSignatureLoadTimeRef = useRef<number>(0);

  // Ajout d'une fonction updateSignatureCache pour mettre √† jour le cache global
  const updateSignatureCache = (participantSig: string | null, companySeal: string | null, organizationSeal: string | null, trainerSig: string | null) => {
    try {
      // Mettre √† jour le cache global
      GLOBAL_SIGNATURE_CACHE.setCache(training.id, participant.id, {
        participantSig,
        companySeal,
        organizationSeal,
        trainerSig
      });
      
      // Mettre √† jour le localStorage
      const localStorageKey = `signatures_cache_${training.id}_${participant.id}`;
      const cacheData = {
        participantSig,
        companySeal,
        organizationSeal,
        trainerSig,
        timestamp: Date.now()
      };
      localStorage.setItem(localStorageKey, JSON.stringify(cacheData));
      console.log('üíæ [CACHE] Signatures mises √† jour dans le cache local');
    } catch (e) {
      console.error('‚ùå [CACHE] Erreur lors de la mise √† jour du cache:', e);
    }
  };

  // Charger imm√©diatement les signatures avant m√™me le premier rendu
  const initialSignatures = loadSignaturesSync(training.id, participant.id);
  
  // Log critique pour diagnostiquer le probl√®me initial
  console.log('üö® [DIAGNOSTIC_CRITIQUE] Initialisation des √©tats avec:', {
    initialSignatures,
    organizationSealInitialValue: initialSignatures.organizationSeal || 'NON PR√âSENT DANS LE CACHE', 
    cacheKeys: Object.keys(initialSignatures)
  });

  const pdfContentRef = useRef<HTMLDivElement>(null);
  const [portalElement, setPortalElement] = useState<HTMLElement | null>(null);
  const [existingDocumentUrl, setExistingDocumentUrl] = useState<string | null>(null);
  const [pdfLoading, setPdfLoading] = useState(true);
  const [pdfError, setPdfError] = useState(false);
  const [documentUrl, setDocumentUrl] = useState<string>('');
  const [isOnlyTrainerSignature, setIsOnlyTrainerSignature] = useState(false);
  const documentCloseCalled = useRef(false);
  const [isGeneratingPDF, setIsGeneratingPDF] = useState(false);
  const [generationError, setGenerationError] = useState<string | null>(null);
  const [generationSuccess, setGenerationSuccess] = useState(false);
  const [generatedPdfUrl, setGeneratedPdfUrl] = useState<string | null>(null);
  const [localSignatureDataURL, setLocalSignatureDataURL] = useState<string | null>(null);
  const [hasParticipantSignature, setHasParticipantSignature] = useState(false);
  const [signatureAction, setSignatureAction] = useState<string | null>(null);
  const [shouldRefresh, setShouldRefresh] = useState(false);
  
  // R√©f√©rence pour savoir si les signatures ont √©t√© charg√©es depuis Supabase
  const signaturesLoadedRef = useRef(false);
  // R√©f√©rence √† l'√©l√©ment conteneur du document
  const documentRef = useRef<HTMLDivElement>(null);
  // R√©f√©rence pour les tentatives de correction du tampon
  const sealAttemptsRef = useRef(0);
  // R√©f√©rence pour le tampon de l'organisme
  const organizationSealRef = useRef<string | null>(null);
  
  // √âtat pour prot√©ger contre les √©tats null qui √©craseraient les signatures charg√©es
  const [signaturesLocked, setSignaturesLocked] = useState(!!initialSignatures.participantSig || !!initialSignatures.companySeal);

  // Ajouter les √©tats pour la signature du formateur (vers ligne 270-280 avec les autres √©tats)
  const [hasTrainerSignature, setHasTrainerSignature] = useState<boolean>(false);

  // Effet s√©par√© pour r√©cup√©rer tous les participants de la formation
  useEffect(() => {
    const fetchAllParticipants = async () => {
      try {
        console.log('üîç [PARTICIPANTS] R√©cup√©ration des participants pour la formation:', training.id);
        
        // Utiliser la fonction SQL cr√©√©e sp√©cifiquement pour r√©cup√©rer les participants d'une formation
        const { data: participantsData, error: participantsError } = await supabase
          .rpc('get_training_participants', { training_uuid: training.id });
          
        // Tableau pour stocker les participants format√©s
        let formattedParticipants: ParticipantData[] = [];
        
        // En cas d'erreur ou si aucun participant n'est trouv√©, utiliser l'utilisateur actuel
        if (participantsError || !participantsData || participantsData.length === 0) {
          console.log('‚ö†Ô∏è [PARTICIPANTS] Aucun participant trouv√© via la fonction RPC:', participantsError || 'Aucune donn√©e');
          
          // Fallback: requ√™te directe sur user_profiles
          const { data: backupData, error: backupError } = await supabase
            .from('user_profiles')
            .select('*')
          .eq('training_id', training.id);
          
          if (backupError || !backupData || backupData.length === 0) {
            console.log('‚ö†Ô∏è [PARTICIPANTS] Fallback √©galement √©chou√©, utilisation du participant actuel uniquement');
            
            // Utilisateur actuel comme fallback
            const currentParticipant: ParticipantData = {
              id: participant.id,
              first_name: participant.first_name,
              last_name: participant.last_name,
              job_position: participant.job_position || '',
              company: participant.company || '',
              email: '',
            status: 'Inscrit'
            };
          
            formattedParticipants = [currentParticipant];
        } else {
            console.log('‚úÖ [PARTICIPANTS] Participants trouv√©s via fallback:', backupData.length);
            formattedParticipants = backupData.map((p: any) => ({
              id: p.id,
              first_name: p.first_name || '',
              last_name: p.last_name || '',
              job_position: p.job_position || '',
              company: p.company || '',
              email: p.email || '',
              status: p.status || 'Inscrit'
            }));
          }
        } else {
          // Des participants ont √©t√© trouv√©s via RPC
          console.log('‚úÖ [PARTICIPANTS] Participants trouv√©s via RPC:', participantsData.length);
          
          // Formater les donn√©es
          formattedParticipants = participantsData.map((p: any) => ({
            id: p.id,
            first_name: p.first_name || '',
            last_name: p.last_name || '',
            job_position: p.job_position || '',
            company: p.company || '',
            email: p.email || '',
            status: p.status || 'Inscrit'
          }));
        }
        
        // S'assurer que l'utilisateur actuel est inclus si n√©cessaire
        const currentParticipantIncluded = formattedParticipants.some(p => p.id === participant.id);
        
        if (!currentParticipantIncluded) {
          console.log('‚ûï [PARTICIPANTS] Ajout du participant actuel qui n\'√©tait pas dans la liste');
          
          formattedParticipants.push({
            id: participant.id,
            first_name: participant.first_name,
            last_name: participant.last_name,
            job_position: participant.job_position || '',
            company: participant.company || '',
            email: '',
            status: 'Inscrit'
          });
        }
        
        // Trier les participants par nom puis pr√©nom
        formattedParticipants.sort((a, b) => {
          if (a.last_name && b.last_name) {
            const lastNameComparison = a.last_name.localeCompare(b.last_name);
            if (lastNameComparison !== 0) return lastNameComparison;
          }
          return a.first_name.localeCompare(b.first_name);
        });
        
        // Afficher les participants dans la console pour v√©rification
        console.log('üîÑ [PARTICIPANTS] Liste finale des participants:', 
          formattedParticipants.map(p => `${p.first_name} ${p.last_name} (${p.company})`));
        
        // Mettre √† jour l'√©tat
        setAllTrainingParticipants(formattedParticipants);
        
      } catch (error) {
        console.error('‚ùå [PARTICIPANTS] Erreur g√©n√©rale:', error);
        
        // En cas d'erreur, utiliser au moins l'utilisateur actuel
        setAllTrainingParticipants([{
          id: participant.id,
          first_name: participant.first_name,
          last_name: participant.last_name,
          job_position: participant.job_position || '',
          company: participant.company || '',
          email: '',
          status: 'Inscrit'
        }]);
      }
    };
    
    fetchAllParticipants();
  }, [training.id, participant.id, participant.first_name, participant.last_name, participant.job_position, participant.company]);

  // Wrapper pour setParticipantSignature qui prot√®ge contre les nulls ind√©sirables
  const safeSetParticipantSignature = useCallback((value: string | null) => {
    if (value || !signaturesLocked) {
      setParticipantSignature(value);
    } else {
      console.log('üîí [PROTECT] Tentative de d√©finir participantSignature √† null bloqu√©e');
    }
  }, [signaturesLocked]);

  // Wrapper pour setCompanySeal qui prot√®ge contre les nulls ind√©sirables
  const safeSetCompanySeal = useCallback((value: string | null) => {
    if (value || !signaturesLocked) {
      setCompanySeal(value);
    } else {
      console.log('üîí [PROTECT] Tentative de d√©finir companySeal √† null bloqu√©e');
    }
  }, [signaturesLocked]);

  // Ajouter la fonction pour mettre √† jour la signature du formateur de mani√®re s√©curis√©e (vers ligne 370-380 avec les autres fonctions safe)
  const safeSetTrainerSignature = useCallback((url: string | null) => {
    console.log('üîí [TRAINER] Mise √† jour s√©curis√©e de la signature du formateur:', 
      url ? `${url.substring(0, 50)}...` : 'null');
    setTrainerSignature(url);
    setHasTrainerSignature(!!url);
  }, []);

  // Ajouter ces fonctions auxiliaires avant l'useEffect qui les utilise
  // Fonction pour r√©cup√©rer la signature du formateur
  const loadTrainerSignature = async () => {
    try {
      console.log('üîç [TRAINER] R√©cup√©ration de la signature du formateur pour la formation:', training.id);
      
      if (!training.trainer_id && !training.trainer_name) {
        console.log('‚ö†Ô∏è [TRAINER] Pas d\'information de formateur disponible pour cette formation');
        return;
      }
      
      // Variable pour stocker les r√©sultats de la recherche
      let trainerFound = false;
      
      // 1. Essayer d'abord par trainer_id si disponible
      if (training.trainer_id) {
        console.log('üîç [TRAINER] Recherche par trainer_id:', training.trainer_id);
        
        // R√©cup√©rer la signature du formateur sp√©cifique √† cette formation
        const { data: trainerSigData, error: trainerSigError } = await supabase
          .from('document_signatures')
          .select('*')
          .eq('training_id', training.id)
          .eq('trainer_id', training.trainer_id)
          .eq('signature_type', 'trainer')
          .order('created_at', { ascending: false })
          .limit(1);
        
        if (trainerSigError) {
          console.error('‚ùå [TRAINER] Erreur lors de la r√©cup√©ration de la signature du formateur par trainer_id:', trainerSigError);
        } else if (trainerSigData && trainerSigData.length > 0 && trainerSigData[0].signature_url) {
          const antiCacheUrl = `${trainerSigData[0].signature_url.split('?')[0]}?t=${Date.now()}&forcereload=true`;
          console.log('‚úÖ [TRAINER] Signature formateur trouv√©e pour la formation:', antiCacheUrl.substring(0, 50) + '...');
          setTrainerSignature(antiCacheUrl);
          setHasTrainerSignature(true);
          trainerFound = true;
        } else {
          console.log('‚ö†Ô∏è [TRAINER] Aucune signature de formateur trouv√©e pour cette formation sp√©cifique avec trainer_id');
        }
      }
      
      // 2. Si pas trouv√© avec trainer_id, essayer par trainer_name
      if (!trainerFound && training.trainer_name) {
        console.log('üîç [TRAINER] Recherche par trainer_name:', training.trainer_name);
        
        // Chercher dans user_profiles en utilisant first_name et last_name (pas full_name)
        const { data: trainerUsers, error: trainerUserError } = await supabase
          .from('user_profiles')
          .select('id, first_name, last_name')
          .or(`first_name.ilike.%${training.trainer_name}%,last_name.ilike.%${training.trainer_name}%`)
          .limit(1);
        
        if (trainerUserError) {
          console.error('‚ùå [TRAINER] Erreur lors de la recherche du formateur par nom:', trainerUserError);
        } else if (trainerUsers && trainerUsers.length > 0) {
          const trainerId = trainerUsers[0].id;
          console.log('‚úÖ [TRAINER] Formateur trouv√© par son nom:', trainerId);
          
          // Chercher la signature avec cet ID
          const { data: trainerNameSig, error: trainerNameError } = await supabase
            .from('document_signatures')
            .select('*')
            .eq('user_id', trainerId)
            .eq('signature_type', 'trainer')
            .order('created_at', { ascending: false })
            .limit(1);
          
          if (trainerNameError) {
            console.error('‚ùå [TRAINER] Erreur lors de la recherche de signature par ID trouv√©:', trainerNameError);
          } else if (trainerNameSig && trainerNameSig.length > 0 && trainerNameSig[0].signature_url) {
            const antiCacheUrl = `${trainerNameSig[0].signature_url.split('?')[0]}?t=${Date.now()}&forcereload=true`;
            console.log('‚úÖ [TRAINER] Signature formateur trouv√©e par nom:', antiCacheUrl.substring(0, 50) + '...');
            setTrainerSignature(antiCacheUrl);
            setHasTrainerSignature(true);
            trainerFound = true;
          }
        } else {
          console.log('‚ö†Ô∏è [TRAINER] Aucun utilisateur trouv√© correspondant au nom du formateur');
        }
      }
      
      // 3. Si toujours pas trouv√©, chercher une signature g√©n√©rique de formateur
      if (!trainerFound) {
        console.log('üîç [TRAINER] Recherche d\'une signature g√©n√©rique de formateur');
        
        // Chercher les signatures de type trainer sans condition sp√©cifique
        const { data: genericTrainerSig, error: genericSigError } = await supabase
          .from('document_signatures')
          .select('*')
          .eq('signature_type', 'trainer')
          .order('created_at', { ascending: false })
          .limit(1);
        
        if (genericSigError) {
          console.error('‚ùå [TRAINER] Erreur lors de la recherche g√©n√©rique de signature formateur:', genericSigError);
        } else if (genericTrainerSig && genericTrainerSig.length > 0 && genericTrainerSig[0].signature_url) {
          const antiCacheUrl = `${genericTrainerSig[0].signature_url.split('?')[0]}?t=${Date.now()}&forcereload=true`;
          console.log('‚úÖ [TRAINER] Signature g√©n√©rique de formateur trouv√©e:', antiCacheUrl.substring(0, 50) + '...');
          setTrainerSignature(antiCacheUrl);
          setHasTrainerSignature(true);
        } else {
          console.log('‚ö†Ô∏è [TRAINER] Aucune signature de formateur trouv√©e (ni sp√©cifique, ni g√©n√©rique)');
          
          // Derni√®re tentative: chercher dans le bucket de stockage
          try {
            const { data: storageFiles, error: storageError } = await supabase.storage
              .from('signatures')
              .list('', { 
                search: 'trainer',
                sortBy: { column: 'created_at', order: 'desc' }
              });
            
            if (storageError) {
              console.error('‚ùå [TRAINER] Erreur lors de la recherche dans le bucket signatures:', storageError);
            } else if (storageFiles && storageFiles.length > 0) {
              const sigFile = storageFiles[0];
              console.log('‚úÖ [TRAINER] Fichier de signature trouv√© dans le bucket:', sigFile.name);
              
              // G√©n√©rer l'URL du fichier trouv√©
              const { data: urlData } = await supabase.storage
                .from('signatures')
                .getPublicUrl(sigFile.name);
              
              if (urlData && urlData.publicUrl) {
                const antiCacheUrl = `${urlData.publicUrl.split('?')[0]}?t=${Date.now()}&forcereload=true`;
                console.log('‚úÖ [TRAINER] URL de signature g√©n√©r√©e depuis le bucket:', antiCacheUrl.substring(0, 50) + '...');
                setTrainerSignature(antiCacheUrl);
                setHasTrainerSignature(true);
              }
            }
          } catch (storageError) {
            console.error('‚ùå [TRAINER] Erreur lors de l\'acc√®s au bucket de stockage:', storageError);
          }
        }
        }
      } catch (error) {
      console.error('‚ùå [TRAINER] Erreur lors du chargement de la signature du formateur:', error);
    }
  };

  // Fonction pour r√©cup√©rer le tampon de l'organisme
  const fetchOrganizationSeal = async (): Promise<string | null> => {
    try {
      console.log('üîç [ORG_SEAL] D√©but de la recherche du tampon d\'organisation');
      
      // V√©rifier d'abord si nous avons d√©j√† ce tampon en cache
      if (organizationSealRef.current) {
        console.log('‚úÖ [ORG_SEAL] Tampon d\'organisation d√©j√† en cache');
        return organizationSealRef.current;
      }
      
      // Chercher d'abord dans document_signatures
      const { data: sealData, error: sealError } = await supabase
        .from('document_signatures')
        .select('*')
        .eq('signature_type', 'organizationSeal')
        .order('created_at', { ascending: false })
        .limit(1);
      
      if (sealError) {
        console.error('‚ùå [ORG_SEAL] Erreur lors de la recherche dans document_signatures:', sealError);
      } else if (sealData && sealData.length > 0 && sealData[0].signature_url) {
        console.log('‚úÖ [ORG_SEAL] Tampon trouv√© dans document_signatures:', sealData[0].signature_url.substring(0, 50) + '...');
        
        // Ajouter un cache buster pour √©viter les probl√®mes de cache
        const url = `${sealData[0].signature_url.split('?')[0]}?t=${Date.now()}&forcereload=true`;
        organizationSealRef.current = url;
        return url;
      }
      
      // Ensuite, chercher dans le bucket de stockage avec le nom standard
      try {
        const { data: storageFiles, error: storageError } = await supabase.storage
          .from('signatures')
          .list('', { 
            search: 'organization_seal',
            sortBy: { column: 'created_at', order: 'desc' }
          });
        
        if (storageError) {
          console.error('‚ùå [ORG_SEAL] Erreur lors de la recherche dans le bucket:', storageError);
        } else if (storageFiles && storageFiles.length > 0) {
          // Identifier le fichier le plus r√©cent qui semble √™tre un tampon d'organisation
          const orgSealFile = storageFiles.find(file => 
            file.name.includes('organization_seal') || 
            file.name.includes('organizationSeal')
          );
          
          if (orgSealFile) {
            console.log('‚úÖ [ORG_SEAL] Tampon trouv√© dans le bucket:', orgSealFile.name);
            
            // G√©n√©rer l'URL publique
            const { data: urlData } = await supabase.storage
              .from('signatures')
              .getPublicUrl(orgSealFile.name);
            
            if (urlData && urlData.publicUrl) {
              // Ajouter un cache buster
              const url = `${urlData.publicUrl.split('?')[0]}?t=${Date.now()}&forcereload=true`;
              console.log('‚úÖ [ORG_SEAL] URL du tampon g√©n√©r√©e:', url.substring(0, 50) + '...');
              
              // Stocker aussi dans document_signatures pour les futures recherches
              try {
                const { error: insertError } = await supabase
                  .from('document_signatures')
                  .insert([{
                    signature_url: urlData.publicUrl,
                    signature_type: 'organizationSeal',
                    type: 'convention',
                    path: orgSealFile.name
                  }]);
                
                if (insertError) {
                  console.error('‚ùå [ORG_SEAL] Erreur lors de l\'enregistrement dans document_signatures:', insertError);
                } else {
                  console.log('‚úÖ [ORG_SEAL] Tampon enregistr√© dans document_signatures');
                }
              } catch (insertErr) {
                console.error('‚ùå [ORG_SEAL] Exception lors de l\'enregistrement:', insertErr);
              }
              
              organizationSealRef.current = url;
              return url;
            }
          }
        }
      } catch (bucketErr) {
        console.error('‚ùå [ORG_SEAL] Exception lors de la recherche dans le bucket:', bucketErr);
      }
      
      // Enfin, chercher dans les settings
      try {
        const { data: settingsData, error: settingsError } = await supabase
          .from('settings')
          .select('organization_seal_url, organization_seal_path')
          .single();
        
        if (settingsError) {
          console.error('‚ùå [ORG_SEAL] Erreur lors de la recherche dans settings:', settingsError);
        } else if (settingsData && settingsData.organization_seal_url) {
          console.log('‚úÖ [ORG_SEAL] Tampon trouv√© dans settings:', settingsData.organization_seal_url.substring(0, 50) + '...');
          
          // Ajouter un cache buster
          const url = `${settingsData.organization_seal_url.split('?')[0]}?t=${Date.now()}&forcereload=true`;
          organizationSealRef.current = url;
          return url;
        } else if (settingsData && settingsData.organization_seal_path) {
          // Si nous avons un chemin mais pas d'URL, g√©n√©rer l'URL
          console.log('üîç [ORG_SEAL] Tentative de g√©n√©ration d\'URL √† partir du chemin:', settingsData.organization_seal_path);
          
          const { data: urlData } = await supabase.storage
            .from('signatures')
            .getPublicUrl(settingsData.organization_seal_path);
          
          if (urlData && urlData.publicUrl) {
            // Ajouter un cache buster
            const url = `${urlData.publicUrl.split('?')[0]}?t=${Date.now()}&forcereload=true`;
            console.log('‚úÖ [ORG_SEAL] URL g√©n√©r√©e √† partir du chemin:', url.substring(0, 50) + '...');
            organizationSealRef.current = url;
            return url;
          }
        }
      } catch (settingsErr) {
        console.error('‚ùå [ORG_SEAL] Exception lors de la recherche dans settings:', settingsErr);
      }
      
      console.log('‚ö†Ô∏è [ORG_SEAL] Aucun tampon d\'organisation trouv√© apr√®s recherche compl√®te');
      return null;
    } catch (error) {
      console.error('‚ùå [ORG_SEAL] Exception g√©n√©rale lors de la recherche du tampon:', error);
      return null;
    }
  };

  // Effet pour charger les signatures depuis Supabase (asynchrone, apr√®s le premier rendu)
  useEffect(() => {
    const loadSignaturesFromSupabase = async () => {
      try {
        // V√©rifier si nous avons charg√© les signatures r√©cemment
        const now = Date.now();
        const timeSinceLastLoad = now - lastSignatureLoadTimeRef.current;
        
        // Ne charger que toutes les 30 secondes maximum
        if (timeSinceLastLoad < 30000 && lastSignatureLoadTimeRef.current > 0) {
          console.log(`‚è±Ô∏è [THROTTLE] Chargement des signatures ignor√© (dernier chargement il y a ${Math.round(timeSinceLastLoad/1000)}s, minimum 30s)`);
          return;
        }
    
        // Mettre √† jour le timestamp du dernier chargement
        lastSignatureLoadTimeRef.current = now;
        
        console.log('üîÑ [SUPABASE] Chargement des signatures depuis Supabase:', {
          training_id: training.id,
          user_id: participant.id,
          trainer_id: training.trainer_id || 'NON SP√âCIFI√â',
          type: 'convention'
        });
        
        // Toujours charger les signatures de Supabase, m√™me si on a d√©j√† v√©rifi√©
        signaturesLoadedRef.current = false;
        
        // 1. R√©cup√©rer la signature du participant
        console.log('üîç [PARTICIPANT] Diagnostic de recherche - param√®tres:', { 
          training_id: training.id, 
          participant_id: participant.id 
        });

        // V√©rifier d'abord avec tous les crit√®res
        const { data: participantSigData, error: participantSigError } = await supabase
          .from('document_signatures')
          .select('*')
          .eq('training_id', training.id)
          .eq('user_id', participant.id)
          .eq('signature_type', 'participant')
          .order('created_at', { ascending: false })
          .limit(10);

        // Log le r√©sultat pour diagnostiquer le probl√®me
        console.log('üîç [PARTICIPANT] R√©sultat de la requ√™te principale:', { 
          found: participantSigData?.length || 0,
          error: participantSigError ? 'Erreur pr√©sente' : 'Pas d\'erreur'
        });

        if (participantSigError) {
          console.error('‚ùå [PARTICIPANT] Erreur lors de la r√©cup√©ration de la signature:', participantSigError);
        } else if (participantSigData && participantSigData.length > 0) {
          // Log toutes les signatures trouv√©es pour analyse
          participantSigData.forEach((sig, index) => {
            console.log(`üîç [PARTICIPANT] Signature #${index + 1}:`, {
              id: sig.id,
              url: sig.signature_url ? sig.signature_url.substring(0, 30) + '...' : 'NULL',
              date: sig.created_at,
              type: sig.signature_type
            });
          });
          
          // Si nous avons trouv√© des signatures valides, utiliser la premi√®re
          const validSignature = participantSigData.find(sig => sig.signature_url);
          
          if (validSignature) {
            const antiCacheUrl = `${validSignature.signature_url.split('?')[0]}?t=${Date.now()}&forcereload=true`;
            console.log('‚úÖ [PARTICIPANT] Signature valide trouv√©e:', antiCacheUrl.substring(0, 50) + '...');
            safeSetParticipantSignature(antiCacheUrl);
            setIsSigned(true);
            setHasParticipantSignature(true);
          } else {
            console.log('‚ö†Ô∏è [PARTICIPANT] Signatures trouv√©es mais aucune URL valide');
          }
        } else {
          console.log('‚ö†Ô∏è [PARTICIPANT] Aucune signature trouv√©e avec crit√®res stricts, recherche √©largie');
          
          // Recherche √©largie sans le training_id
          const { data: widerSearchData, error: widerSearchError } = await supabase
            .from('document_signatures')
            .select('*')
            .eq('user_id', participant.id)
            .eq('signature_type', 'participant')
            .order('created_at', { ascending: false })
            .limit(5);
          
          console.log('üîç [PARTICIPANT] R√©sultat recherche √©largie:', { 
            found: widerSearchData?.length || 0,
            error: widerSearchError ? 'Erreur pr√©sente' : 'Pas d\'erreur'
          });
          
          if (widerSearchData && widerSearchData.length > 0 && widerSearchData[0].signature_url) {
            const antiCacheUrl = `${widerSearchData[0].signature_url.split('?')[0]}?t=${Date.now()}&forcereload=true`;
            console.log('‚úÖ [PARTICIPANT] Signature trouv√©e via recherche √©largie:', antiCacheUrl.substring(0, 50) + '...');
            safeSetParticipantSignature(antiCacheUrl);
            setIsSigned(true);
            setHasParticipantSignature(true);
          } else {
            console.log('‚ö†Ô∏è [PARTICIPANT] Aucune signature trouv√©e, tentative avec le bucket de stockage');
            
            // Recherche directe dans le bucket de stockage
            try {
              // Rechercher avec des motifs potentiels
              const searchPatterns = [
                `participant_${participant.id}_${training.id}`,
                `participant_${participant.id}`,
                `${participant.first_name.toLowerCase()}_${participant.last_name.toLowerCase()}`
              ];
              
              let foundSignature = false;
              
              for (const pattern of searchPatterns) {
                if (foundSignature) break;
                
                console.log(`üîç [PARTICIPANT] Recherche dans bucket avec pattern: ${pattern}`);
                
                const { data: storageFiles, error: storageError } = await supabase.storage
                  .from('signatures')
                  .list('', { 
                    search: pattern,
                    sortBy: { column: 'created_at', order: 'desc' }
                  });
                
                if (storageError) {
                  console.error(`‚ùå [PARTICIPANT] Erreur recherche storage pattern ${pattern}:`, storageError);
                  continue;
                }
                
                console.log(`üîç [PARTICIPANT] R√©sultats pour pattern ${pattern}:`, storageFiles?.length || 0);
                
                if (storageFiles && storageFiles.length > 0) {
                  // Filtrer pour ne garder que les fichiers signature/participant
                  const relevantFiles = storageFiles.filter(file => 
                    file.name.includes('participant') || 
                    file.name.includes('signature')
                  );
                  
                  if (relevantFiles.length > 0) {
                    const mostRecentFile = relevantFiles[0];
                    console.log('‚úÖ [PARTICIPANT] Fichier signature trouv√© dans bucket:', mostRecentFile.name);
                    
                    // G√©n√©rer l'URL
                    const { data: urlData } = await supabase.storage
                      .from('signatures')
                      .getPublicUrl(mostRecentFile.name);
                    
                    if (urlData && urlData.publicUrl) {
                      const antiCacheUrl = `${urlData.publicUrl.split('?')[0]}?t=${Date.now()}&forcereload=true`;
                      console.log('‚úÖ [PARTICIPANT] URL g√©n√©r√©e depuis bucket:', antiCacheUrl.substring(0, 50) + '...');
                      
                      // Enregistrer aussi dans document_signatures pour les futures recherches
                      try {
                        const { data: insertData, error: insertError } = await supabase
                          .from('document_signatures')
                          .insert([{
                            user_id: participant.id,
                            training_id: training.id,
                            signature_url: urlData.publicUrl,
                            signature_type: 'participant',
                            type: 'convention',
                            path: mostRecentFile.name
                          }]);
                        
                        if (insertError) {
                          console.error('‚ùå [PARTICIPANT] Erreur lors de l\'enregistrement de la r√©f√©rence:', insertError);
                        } else {
                          console.log('‚úÖ [PARTICIPANT] R√©f√©rence enregistr√©e dans document_signatures');
                        }
                      } catch (insertErr) {
                        console.error('‚ùå [PARTICIPANT] Exception lors de l\'enregistrement de la r√©f√©rence:', insertErr);
                      }
                      
                      safeSetParticipantSignature(antiCacheUrl);
                      setIsSigned(true);
                      setHasParticipantSignature(true);
                      foundSignature = true;
                      break;
                    }
                  }
                }
              }
            } catch (storageErr) {
              console.error('‚ùå [PARTICIPANT] Exception lors de la recherche dans le bucket:', storageErr);
            }
          }
        }
        
        // 2. R√©cup√©rer le tampon de l'entreprise
        console.log('üîç [COMPANY] Diagnostic de recherche du tampon d\'entreprise - param√®tres:', {
          training_id: training.id,
          user_id: participant.id,
          company_id: training.company_id || 'NON SP√âCIFI√â'
        });
        
        // Strat√©gie 1: Chercher par training_id et user_id
        let { data: companySealData, error: companySealError } = await supabase
          .from('document_signatures')
          .select('*')
          .eq('training_id', training.id)
          .eq('user_id', participant.id)
          .eq('signature_type', 'companySeal')
          .order('created_at', { ascending: false })
          .limit(5);
        
        console.log('üîç [COMPANY] R√©sultat recherche par training_id et user_id:', {
          found: companySealData?.length || 0,
          error: companySealError ? 'Erreur pr√©sente' : 'Pas d\'erreur'
        });

        // Strat√©gie 2: Si aucun r√©sultat ou erreur, rechercher par company_id si disponible
        if ((!companySealData || companySealData.length === 0) && training.company_id) {
          console.log('üîç [COMPANY] Recherche par company_id:', training.company_id);
          
          const { data: companyData, error: companyError } = await supabase
            .from('document_signatures')
            .select('*')
            .eq('company_id', training.company_id)
            .eq('signature_type', 'companySeal')
            .order('created_at', { ascending: false })
            .limit(5);
          
          console.log('üîç [COMPANY] R√©sultat recherche par company_id:', { 
            found: companyData?.length || 0,
            error: companyError ? 'Erreur pr√©sente' : 'Pas d\'erreur' 
          });
          
          if (companyError) {
            console.error('‚ùå [COMPANY] Erreur lors de la recherche par company_id:', companyError);
          } else if (companyData && companyData.length > 0) {
            companySealData = companyData;
            companySealError = null;
          }
        }
        
        // Traitement des r√©sultats du tampon d'entreprise
        if (companySealError) {
          console.error('‚ùå [COMPANY] Erreur lors de la r√©cup√©ration du tampon:', companySealError);
        } else if (companySealData && companySealData.length > 0) {
          // Log tous les tampons trouv√©s pour diagnostic
          companySealData.forEach((seal, index) => {
            console.log(`üîç [COMPANY] Tampon #${index + 1}:`, {
              id: seal.id,
              url: seal.signature_url ? seal.signature_url.substring(0, 30) + '...' : 'NULL',
              date: seal.created_at
            });
          });
          
          // Si nous avons trouv√© des tampons valides, utiliser le premier
          const validSeal = companySealData.find(seal => seal.signature_url);
          
          if (validSeal) {
            const antiCacheUrl = `${validSeal.signature_url.split('?')[0]}?t=${Date.now()}&forcereload=true`;
            console.log('‚úÖ [COMPANY] Tampon valide trouv√©:', antiCacheUrl.substring(0, 50) + '...');
            safeSetCompanySeal(antiCacheUrl);
          } else {
            console.log('‚ö†Ô∏è [COMPANY] Tampons trouv√©s mais aucune URL valide');
          }
        } else {
          console.log('‚ö†Ô∏è [COMPANY] Aucun tampon trouv√© dans document_signatures, tentative via le bucket');
          
          // Recherche directe dans le bucket de stockage
          try {
            // Rechercher avec des motifs potentiels
            const searchPatterns = [
              `companyseal_${participant.id}_${training.id}`,
              `companyseal_${participant.id}`,
              training.company_id ? `companyseal_${training.company_id}` : ''
            ].filter(pattern => pattern); // Filtrer les cha√Ænes vides
            
            let foundSeal = false;
            
            for (const pattern of searchPatterns) {
              if (foundSeal) break;
              
              console.log(`üîç [COMPANY] Recherche dans bucket avec pattern: ${pattern}`);
              
              const { data: storageFiles, error: storageError } = await supabase.storage
                .from('signatures')
                .list('', { 
                  search: pattern,
                  sortBy: { column: 'created_at', order: 'desc' }
                });
              
              if (storageError) {
                console.error(`‚ùå [COMPANY] Erreur recherche storage pattern ${pattern}:`, storageError);
                continue;
              }
              
              console.log(`üîç [COMPANY] R√©sultats pour pattern ${pattern}:`, storageFiles?.length || 0);
              
              if (storageFiles && storageFiles.length > 0) {
                // Filtrer pour ne garder que les fichiers de tampon d'entreprise
                const relevantFiles = storageFiles.filter(file => 
                  file.name.includes('companySeal') || 
                  file.name.includes('companyseal') ||
                  file.name.includes('company_seal')
                );
                
                if (relevantFiles.length > 0) {
                  const mostRecentFile = relevantFiles[0];
                  console.log('‚úÖ [COMPANY] Fichier tampon trouv√© dans bucket:', mostRecentFile.name);
                  
                  // G√©n√©rer l'URL
                  const { data: urlData } = await supabase.storage
                    .from('signatures')
                    .getPublicUrl(mostRecentFile.name);
                  
                  if (urlData && urlData.publicUrl) {
                    const antiCacheUrl = `${urlData.publicUrl.split('?')[0]}?t=${Date.now()}&forcereload=true`;
                    console.log('‚úÖ [COMPANY] URL du tampon g√©n√©r√©e depuis bucket:', antiCacheUrl.substring(0, 50) + '...');
                    
                    // Enregistrer aussi dans document_signatures pour les futures recherches
                    try {
                      const { data: insertData, error: insertError } = await supabase
                        .from('document_signatures')
                        .insert([{
                          user_id: participant.id,
                          training_id: training.id,
                          company_id: training.company_id,
                          signature_url: urlData.publicUrl,
                          signature_type: 'companySeal',
                          type: 'convention',
                          path: mostRecentFile.name
                        }]);
                      
                      if (insertError) {
                        console.error('‚ùå [COMPANY] Erreur lors de l\'enregistrement de la r√©f√©rence:', insertError);
                      } else {
                        console.log('‚úÖ [COMPANY] R√©f√©rence enregistr√©e dans document_signatures');
                      }
                    } catch (insertErr) {
                      console.error('‚ùå [COMPANY] Exception lors de l\'enregistrement de la r√©f√©rence:', insertErr);
                    }
                    
                    safeSetCompanySeal(antiCacheUrl);
                    foundSeal = true;
                    break;
                  }
                }
              }
            }
            
            if (!foundSeal) {
              console.log('‚ö†Ô∏è [COMPANY] Aucun tampon d\'entreprise trouv√© dans le bucket apr√®s recherche approfondie');
            }
          } catch (storageErr) {
            console.error('‚ùå [COMPANY] Exception lors de la recherche dans le bucket:', storageErr);
          }
        }
        
        // 3. R√©cup√©rer la signature du formateur pour cette formation sp√©cifique
        await loadTrainerSignature();
        
        // 4. R√©cup√©rer le tampon d'organisme (qui est global)
        await fetchOrganizationSeal();
        
        // Mettre √† jour le cache avec les signatures trouv√©es
        updateSignatureCache(
          participantSignature,
          companySeal,
          organizationSeal,
          trainerSignature
        );
        
        signaturesLoadedRef.current = true;
    } catch (error) {
        console.error('‚ùå [SUPABASE] Erreur lors du chargement des signatures:', error);
      }
    };
    
    // Lancer le chargement asynchrone
    loadSignaturesFromSupabase();
  }, [training.id, participant.id, safeSetParticipantSignature, safeSetCompanySeal, participantSignature, companySeal, organizationSeal, trainerSignature, updateSignatureCache, loadTrainerSignature, fetchOrganizationSeal, training.company_id]);

  // Moniteur d'√©tat des signatures
  useEffect(() => {
    console.log('üëÅÔ∏è [MONITOR] √âtat des signatures:', {
      participantSignature: participantSignature ? '‚úÖ Pr√©sente' : '‚ùå Absente',
      companySeal: companySeal ? '‚úÖ Pr√©sent' : '‚ùå Absent',
      trainerSignature: trainerSignature ? '‚úÖ Pr√©sente' : '‚ùå Absente',
      signaturesLocked: signaturesLocked ? 'üîí Verrouill√©es' : 'üîì D√©verrouill√©es'
    });
  }, [participantSignature, companySeal, trainerSignature, signaturesLocked]);

  // Effet pour v√©rifier l'accessibilit√© des tampons d√®s le chargement
  useEffect(() => {
    const verifySeals = async () => {
      if (companySeal || organizationSeal) {
        console.log('üîç [INITIALIZATION] V√©rification de l\'accessibilit√© des tampons');
        
        try {
          // Importer de mani√®re dynamique pour √©viter les probl√®mes de r√©f√©rence circulaire
          const { checkSealAccess } = await import('../utils/SignatureUtils');
          
          // V√©rifier et potentiellement optimiser les URLs des tampons
          const { companySeal: optimizedCompanySeal, organizationSeal: optimizedOrgSeal, diagnosticMessage } = 
            await checkSealAccess({
              companySeal,
              organizationSeal
            });
          
          console.log(`üîç [INITIALIZATION] Diagnostic des tampons: ${diagnosticMessage}`);
          
          // Mettre √† jour les URLs si elles ont √©t√© optimis√©es
          if (optimizedCompanySeal && optimizedCompanySeal !== companySeal) {
            console.log('üîç [INITIALIZATION] Mise √† jour de l\'URL du tampon d\'entreprise');
            setCompanySeal(optimizedCompanySeal);
          }
          
          if (optimizedOrgSeal && optimizedOrgSeal !== organizationSeal) {
            console.log('üîç [INITIALIZATION] Mise √† jour de l\'URL du tampon d\'organisme');
            setOrganizationSeal(optimizedOrgSeal);
          }
          
          // Retourner le r√©sultat pour un usage ult√©rieur
          return { companySeal: optimizedCompanySeal, organizationSeal: optimizedOrgSeal };
        } catch (error) {
          console.error('‚ùå [ERROR] Erreur lors de la v√©rification des tampons:', error);
          return { companySeal, organizationSeal };
        }
      }
      
      return { companySeal, organizationSeal };
    };
    
    // Lancer la v√©rification
    verifySeals();
  }, [companySeal, organizationSeal]);

  useEffect(() => {
    // Cr√©er un √©l√©ment div pour le portail s'il n'existe pas d√©j√†
    const existingPortal = document.getElementById('training-agreement-portal');
    if (existingPortal) {
      setPortalElement(existingPortal);
    } else {
      const newPortalElement = document.createElement('div');
      newPortalElement.id = 'training-agreement-portal';
      document.body.appendChild(newPortalElement);
      setPortalElement(newPortalElement);
    }

    // Appeler onDocumentOpen si fourni
    if (onDocumentOpen) {
      onDocumentOpen();
    }
    
    // D√©sactiver le cache des images pour les signatures
    const meta = document.createElement('meta');
    meta.httpEquiv = 'Cache-Control';
    meta.content = 'no-cache, no-store, must-revalidate';
    document.head.appendChild(meta);
    
    const pragmaMeta = document.createElement('meta');
    pragmaMeta.httpEquiv = 'Pragma';
    pragmaMeta.content = 'no-cache';
    document.head.appendChild(pragmaMeta);
    
    const expiresMeta = document.createElement('meta');
    expiresMeta.httpEquiv = 'Expires';
    expiresMeta.content = '0';
    document.head.appendChild(expiresMeta);

    // Configurer les options de visualisation pour les images externes
    document.querySelectorAll('img').forEach(img => {
      img.setAttribute('crossorigin', 'anonymous');
      
      // Si c'est une signature, appliquer des attributs suppl√©mentaires
      if (img.src.includes('signatures/') || img.alt?.toLowerCase().includes('signature')) {
        img.setAttribute('loading', 'eager');
        img.setAttribute('decoding', 'async');
        img.style.visibility = 'visible';
        img.style.display = 'block';
      }
    });

    // Cleanup function
    return () => {
      // Appeler onDocumentClose si fourni et s'il n'a pas d√©j√† √©t√© appel√©
      if (onDocumentClose && !documentCloseCalled.current) {
        documentCloseCalled.current = true;
        onDocumentClose();
      }
      
      // Nettoyer les meta tags
      document.querySelectorAll('meta[http-equiv="Cache-Control"]').forEach(el => el.remove());
      document.querySelectorAll('meta[http-equiv="Pragma"]').forEach(el => el.remove());
      document.querySelectorAll('meta[http-equiv="Expires"]').forEach(el => el.remove());
      
      const portal = document.getElementById('training-agreement-portal');
      if (portal && portal.childNodes.length === 0) {
        portal.remove();
      }
    };
  }, []);

  // Effet pour r√©cup√©rer les donn√©es de l'entreprise et de l'organisme
  useEffect(() => {
    const fetchCompanyAndSettings = async () => {
      try {
        // R√©cup√©rer les param√®tres de l'organisme de formation
        const { data: settingsData, error: settingsError } = await supabase
          .from('settings')
          .select('*')
          .single();

        if (settingsError) {
          console.error('Erreur lors de la r√©cup√©ration des param√®tres:', settingsError);
        } else if (settingsData) {
          // Transformer les donn√©es dans le format attendu par le template
          const formattedSettings: OrganizationSettings = {
            organization_name: settingsData.company_name || 'PETITMAKER',
            siret: settingsData.siret || '928 386 044 00012',
            address: settingsData.address || '2 rue H√©racl√®s',
            postal_code: settingsData.postal_code || '59650',
            city: settingsData.city || 'Villeneuve-d\'Ascq',
            country: settingsData.country || 'France',
            representative_name: 'Nicolas Cleton',
            representative_title: 'Pr√©sident',
            activity_declaration_number: settingsData.training_number || '32 59 10753 59',
            organization_seal_url: settingsData.organization_seal_url
          };
          setOrganizationSettings(formattedSettings);
        }

        // R√©cup√©rer les donn√©es compl√®tes de la formation pour corriger les probl√®mes de format des donn√©es
        const { data: fullTrainingData, error: fullTrainingError } = await supabase
          .from('trainings')
          .select('*')
          .eq('id', training.id)
          .single();
        
        if (fullTrainingError) {
          console.error('Erreur lors de la r√©cup√©ration des donn√©es compl√®tes de la formation:', fullTrainingError);
        } else if (fullTrainingData) {
          console.log('‚úÖ [DATA] Donn√©es compl√®tes de la formation r√©cup√©r√©es:', fullTrainingData);
          console.log('‚úÖ [PRICE] Prix r√©cup√©r√©:', fullTrainingData.price);
          
          // S'assurer que le prix est bien un nombre ou null
          const price = fullTrainingData.price !== undefined ? 
            (typeof fullTrainingData.price === 'string' ? parseFloat(fullTrainingData.price) : fullTrainingData.price) : 
            null;
          
          // Parser correctement les donn√©es qui sont parfois stock√©es sous forme de cha√Ænes JSON
          const parsedTraining = {
            ...training,
            price: price,
            objectives: parseJsonField(fullTrainingData.objectives) || training.objectives,
            evaluation_methods: parseJsonField(fullTrainingData.evaluation_methods) || training.evaluation_methods,
            tracking_methods: parseJsonField(fullTrainingData.tracking_methods) || training.tracking_methods,
            pedagogical_methods: parseJsonField(fullTrainingData.pedagogical_methods) || training.pedagogical_methods,
            material_elements: parseJsonField(fullTrainingData.material_elements) || training.material_elements,
          };
          
          console.log('üîÑ [DATA] Donn√©es de formation pars√©es:', parsedTraining);
          console.log('üîÑ [PRICE] Prix apr√®s parsing:', parsedTraining.price);
          
          // Mise √† jour directe des propri√©t√©s de l'objet training
          Object.assign(training, parsedTraining);
        }

        // R√©cup√©rer les informations sur la soci√©t√© associ√©e √† la formation
        if (training.company_id) {
          const { data: companyData, error: companyError } = await supabase
            .from('companies')
            .select('*')
            .eq('id', training.company_id)
            .single();

          if (companyError) {
            console.error('Erreur lors de la r√©cup√©ration de la soci√©t√©:', companyError);
            
            // Si pas de company_id mais que le participant a une entreprise renseign√©e, essayer de la trouver
            if (participant.company) {
              console.log('üîç [DEBUG] Pas de company_id trouv√©e, recherche par nom:', participant.company);
              
              const { data: companyByNameData, error: companyByNameError } = await supabase
                .from('companies')
                .select('*')
                .ilike('name', `%${participant.company}%`)
                .limit(1)
                .single();
              
              if (companyByNameError) {
                console.log('‚ö†Ô∏è [WARN] Entreprise non trouv√©e par nom:', companyByNameError);
                
                // Cr√©er une entreprise de base √† partir du nom
                setCompany({
                  name: participant.company,
                  address: participant.company ? 'Adresse non renseign√©e' : '√Ä compl√©ter',
                  postal_code: '',
                  city: '',
                  siret: participant.company ? 'SIRET non renseign√©' : '√Ä compl√©ter'
                });
              } else if (companyByNameData) {
                console.log('‚úÖ [SUCCESS] Entreprise trouv√©e par nom:', companyByNameData);
                setCompany(companyByNameData);
              }
            } else {
              // Si pas d'entreprise renseign√©e, utiliser une valeur par d√©faut
              setCompany({
                name: '√Ä compl√©ter',
                address: '√Ä compl√©ter',
                postal_code: '',
                city: '',
                siret: '√Ä compl√©ter'
              });
            }
          } else if (companyData) {
            setCompany(companyData);
          }
        } else if (participant.company) {
          // Si pas de company_id mais que le participant a une entreprise renseign√©e, essayer de la trouver
          console.log('üîç [DEBUG] Pas de company_id, recherche par nom:', participant.company);
          
          const { data: companyByNameData, error: companyByNameError } = await supabase
            .from('companies')
            .select('*')
            .ilike('name', `%${participant.company}%`)
            .limit(1)
            .single();
          
          if (companyByNameError) {
            console.log('‚ö†Ô∏è [WARN] Entreprise non trouv√©e par nom:', companyByNameError);
            
            // Cr√©er une entreprise de base √† partir du nom
            setCompany({
              name: participant.company,
              address: participant.company ? 'Adresse non renseign√©e' : '√Ä compl√©ter',
              postal_code: '',
              city: '',
              siret: participant.company ? 'SIRET non renseign√©' : '√Ä compl√©ter'
            });
          } else if (companyByNameData) {
            console.log('‚úÖ [SUCCESS] Entreprise trouv√©e par nom:', companyByNameData);
            setCompany(companyByNameData);
          }
        } else {
          // Si pas d'entreprise renseign√©e, utiliser une valeur par d√©faut
          setCompany({
            name: '√Ä compl√©ter',
            address: '√Ä compl√©ter',
            postal_code: '',
            city: '',
            siret: '√Ä compl√©ter'
          });
                      }
                    } catch (error) {
        console.error('Erreur lors de la r√©cup√©ration des donn√©es:', error);
                    }
                  };
                  
                  fetchCompanyAndSettings();
  }, [training.company_id, participant.company]);

  // Apr√®s avoir re√ßu la signature du participant
  useEffect(() => {
    if (participantSignature) {
      setHasParticipantSignature(true);
    }
  }, [participantSignature]);

  // Effet pour r√©cup√©rer le tampon de l'organisme et le m√©moriser
  useEffect(() => {
    const checkAndLoadOrganizationSeal = async () => {
      try {
        // D'abord v√©rifier dans le cache
        const cachedSeal = initialSignatures.organizationSeal;
        if (cachedSeal) {
          console.log('‚úÖ [ORG_SEAL] Tampon trouv√© dans le cache:', cachedSeal);
          setOrganizationSeal(cachedSeal);
          // Actualiser aussi le cache pour ne pas perdre l'information
          updateSignatureCache(participantSignature, companySeal, cachedSeal, trainerSignature);
          return;
        }
        
        // V√©rifier si nous avons d√©j√† une URL de tampon dans les param√®tres de l'organisme
        if (organizationSettings?.organization_seal_url) {
          console.log('‚úÖ [ORG_SEAL] URL du tampon trouv√©e dans les param√®tres:', organizationSettings.organization_seal_url);
          
          // Ajouter un param√®tre anticache
          const baseUrl = organizationSettings.organization_seal_url.split('?')[0];
          const timestamp = Date.now();
          const antiCacheUrl = `${baseUrl}?t=${timestamp}&forcereload=true`;
          
          // Attribuer directement l'URL au tampon d'organisme
          setOrganizationSeal(antiCacheUrl);
          // Mettre √† jour le cache √©galement
          updateSignatureCache(participantSignature, companySeal, antiCacheUrl, trainerSignature);
          return;
        }
        
        // Si aucune URL n'est pr√©sente dans les param√®tres, rechercher dans les signatures
        const { data: sealData, error: sealError } = await supabase
          .from('document_signatures')
          .select('signature_url')
          .eq('signature_type', 'organizationSeal')
          .order('created_at', { ascending: false })
          .limit(1)
          .single();
          
        if (sealError) {
          console.log('‚ö†Ô∏è [ORG_SEAL] Aucun tampon trouv√© dans document_signatures:', sealError);
          return;
        }
        
        if (sealData && sealData.signature_url) {
          console.log('‚úÖ [ORG_SEAL] Tampon trouv√© dans document_signatures:', sealData.signature_url);
          
          // Ajouter un param√®tre anticache
          const baseUrl = sealData.signature_url.split('?')[0];
          const timestamp = Date.now();
          const antiCacheUrl = `${baseUrl}?t=${timestamp}&forcereload=true`;
          
          // Attribuer l'URL au tampon d'organisme
          setOrganizationSeal(antiCacheUrl);
          // Mettre √† jour le cache √©galement
          updateSignatureCache(participantSignature, companySeal, antiCacheUrl, trainerSignature);
        }
      } catch (error) {
        console.error('‚ùå [ORG_SEAL] Erreur lors de la r√©cup√©ration du tampon d\'organisme:', error);
      }
    };
    
    // Ex√©cuter seulement si nous avons les param√®tres de l'organisme et que le tampon n'est pas d√©j√† d√©fini
    if ((organizationSettings || initialSignatures.organizationSeal) && !organizationSeal) {
      checkAndLoadOrganizationSeal();
    }
  }, [organizationSettings, organizationSeal, initialSignatures, updateSignatureCache, participantSignature, companySeal, trainerSignature]);

  // Lors de la signature locale
  const handleSignatureComplete = (dataURL: string) => {
    setLocalSignatureDataURL(dataURL);
    setHasParticipantSignature(true);
  };

  const generatePDF = async () => {
    if (!pdfContentRef.current) return;
    
    try {
      // G√©n√©rer un nom de fichier bas√© sur le nom du participant et le titre de la formation
      const fileName = `Convention_${participant.first_name}_${participant.last_name}_${training.title.replace(/\s+/g, '_')}.pdf`;
      
      // Utiliser html2pdf pour g√©n√©rer et afficher le PDF
      const pdfBlob = await html2pdf().from(pdfContentRef.current).outputPdf('blob');
      
      // Cr√©er une URL du blob et l'ouvrir dans une nouvelle fen√™tre
      const blobUrl = URL.createObjectURL(pdfBlob);
      window.open(blobUrl, '_blank');
    } catch (error) {
      console.error('Erreur lors de la g√©n√©ration du PDF:', error);
      alert('Une erreur est survenue lors de la g√©n√©ration du PDF. Veuillez r√©essayer.');
    }
  };

  const formatDate = (dateString: string | null) => {
    if (!dateString) return '';
    try {
      const date = new Date(dateString);
      return format(date, 'dd/MM/yyyy', { locale: fr });
    } catch (e) {
      console.error('Erreur de formatage de date:', e);
      return dateString;
    }
  };

  const getCurrentDate = () => {
    return format(new Date(), 'dd MMMM yyyy', { locale: fr });
  };

  const getTrainingDates = () => {
    const startDate = formatDate(training.start_date);
    const endDate = formatDate(training.end_date);
    
    if (startDate && endDate) {
      if (startDate === endDate) {
        return `Le ${startDate}`;
      }
      return `Du ${startDate} au ${endDate}`;
    }
    return 'Dates √† d√©finir';
  };

  const getObjectives = () => {
    // G√©rer les diff√©rents formats d'objectifs possibles
    if (Array.isArray(training.objectives) && training.objectives.length > 0) {
      return training.objectives;
    }
    
    if (typeof training.objectives === 'string') {
      try {
        // Tenter de parser si c'est un JSON stringifi√©
        const parsed = JSON.parse(training.objectives);
        if (Array.isArray(parsed)) {
          return parsed;
        } else if (typeof parsed === 'object') {
          // Si c'est un objet, extraire ses valeurs
          return Object.values(parsed).filter(v => !!v);
        }
        // Sinon, traiter comme une cha√Æne
        return [training.objectives];
      } catch {
        // Si ce n'est pas du JSON valide, traiter comme une cha√Æne simple
        return [training.objectives];
      }
    }
    
    return ['Objectifs √† d√©finir'];
  };

  const getEvaluationMethods = () => {
    const methods = [];
    const evals = training.evaluation_methods || {};
    
    if (evals.profile_evaluation) methods.push('√âvaluation de profil');
    if (evals.skills_evaluation) methods.push('√âvaluation des comp√©tences');
    if (evals.knowledge_evaluation) methods.push('√âvaluation des connaissances');
    if (evals.satisfaction_survey) methods.push('Questionnaire de satisfaction');
    
    return methods.length > 0 ? methods : ['M√©thode d\'√©valuation √† d√©finir'];
  };

  const getPedagogicalMethods = () => {
    const methods = [];
    const pedagogy = training.pedagogical_methods || {};
    
    if (pedagogy.needs_evaluation) methods.push('√âvaluation des besoins');
    if (pedagogy.theoretical_content) methods.push('Contenu th√©orique');
    if (pedagogy.practical_exercises) methods.push('Exercices pratiques');
    if (pedagogy.case_studies) methods.push('√âtudes de cas');
    if (pedagogy.experience_sharing) methods.push('Partage d\'exp√©rience');
    if (pedagogy.digital_support) methods.push('Support num√©rique');
    
    return methods.length > 0 ? methods : ['M√©thodes p√©dagogiques √† d√©finir'];
  };

  const getMaterialElements = () => {
    const elements = [];
    const material = training.material_elements || {};
    
    if (material.computer_provided) elements.push('Ordinateur fourni');
    if (material.pedagogical_material) elements.push('Support p√©dagogique');
    if (material.digital_support_provided) elements.push('Support num√©rique fourni');
    
    return elements.length > 0 ? elements : ['√âl√©ments mat√©riels √† d√©finir'];
  };

  // Fonction pour trouver les signatures dans le document
  const findSignatureImagesInDocument = (): { participantImage?: HTMLImageElement; representativeImage?: HTMLImageElement } => {
    const result: { participantImage?: HTMLImageElement; representativeImage?: HTMLImageElement } = {};
    
    if (!pdfContentRef.current) {
      console.log('üîç [DEBUG] pdfContentRef est null, impossible de chercher les signatures');
      return result;
    }
    
    // Rechercher avec les s√©lecteurs les plus pr√©cis en premier
    // 1. Rechercher par attributs data-* sp√©cifiques (m√©thode la plus fiable)
    const dataSignatureImages = pdfContentRef.current.querySelectorAll('[data-signature="true"]');
    console.log(`üîç [DEBUG] ${dataSignatureImages.length} images avec attribut data-signature="true" trouv√©es`);
    
    if (dataSignatureImages.length > 0) {
      dataSignatureImages.forEach((img) => {
        const imgEl = img as HTMLImageElement;
        const type = imgEl.getAttribute('data-signature-type');
        console.log(`üîç [DEBUG] Image de signature trouv√©e avec type: ${type}`, imgEl);
        
        if (type === 'participant') {
          result.participantImage = imgEl;
          console.log('‚úÖ [DEBUG] Image de signature du participant trouv√©e dans le document');
        } else if (type === 'representative') {
          result.representativeImage = imgEl;
          console.log('‚úÖ [DEBUG] Image de signature du repr√©sentant trouv√©e dans le document');
        }
      });
    }
    
    // 2. Si les attributs data-* n'ont pas fonctionn√©, rechercher par conteneurs parents
    if (!result.participantImage || !result.representativeImage) {
      console.log('üîç [DEBUG] Recherche de signatures par conteneurs parents');
      
      // Rechercher les conteneurs de signature
      const participantContainer = pdfContentRef.current.querySelector('[data-signature-container="participant"]');
      const representativeContainer = pdfContentRef.current.querySelector('[data-signature-container="representative"]');
      
      if (participantContainer && !result.participantImage) {
        const img = participantContainer.querySelector('img');
        if (img) {
          result.participantImage = img as HTMLImageElement;
          console.log('‚úÖ [DEBUG] Image de signature du participant trouv√©e par conteneur parent');
        }
      }
      
      if (representativeContainer && !result.representativeImage) {
        const img = representativeContainer.querySelector('img');
        if (img) {
          result.representativeImage = img as HTMLImageElement;
          console.log('‚úÖ [DEBUG] Image de signature du repr√©sentant trouv√©e par conteneur parent');
        }
      }
    }
    
    // 3. Si aucune image n'a √©t√© trouv√©e, utiliser une m√©thode moins pr√©cise
    if (!result.participantImage && !result.representativeImage) {
      console.log('‚ö†Ô∏è [DEBUG] Aucune signature trouv√©e avec les m√©thodes pr√©cises, utilisation d\'heuristiques');
      
      // Rechercher toutes les images du document
      const allImages = pdfContentRef.current.querySelectorAll('img');
      console.log(`üîç [DEBUG] ${allImages.length} images trouv√©es au total dans le document`);
      
      allImages.forEach((img) => {
        const imgEl = img as HTMLImageElement;
        const src = imgEl.src || '';
        
        // Analyser l'URL pour d√©terminer le type de signature
        if (src.includes('participant_convention') && !result.participantImage) {
          result.participantImage = imgEl;
          console.log('‚úÖ [DEBUG] Image de signature du participant trouv√©e par heuristique URL');
        } else if ((src.includes('representative_convention') || 
                   src.includes('trainer_convention')) && 
                  !result.representativeImage) {
          result.representativeImage = imgEl;
          console.log('‚úÖ [DEBUG] Image de signature du repr√©sentant trouv√©e par heuristique URL');
        }
      });
    }
    
    // R√©sum√© final
    console.log('üîç [DEBUG] R√©capitulatif des signatures trouv√©es:');
    console.log('- Participant:', result.participantImage ? '‚úÖ Trouv√©e' : '‚ùå Non trouv√©e');
    console.log('- Repr√©sentant:', result.representativeImage ? '‚úÖ Trouv√©e' : '‚ùå Non trouv√©e');
    
    return result;
  };

  // D√©tecter si on est sur mobile
  const isMobile = window.innerWidth < 768;

  // Journaux pour le d√©bogage des donn√©es du template
  useEffect(() => {
    console.log('üß© [DEBUG] StudentTrainingAgreement - Rendu principal du template avec:', {
      'company complet': company,
      'a-t-on une entreprise': !!company,
      'props participant': participant,
      'a-t-on une entreprise participant': !!participant.company 
    });
  }, [company, participant]);

  // D√©finition de l'objet trainingAgreement pour centraliser les informations de signature
  useEffect(() => {
    // Cr√©ation de l'objet trainingAgreement qui stocke toutes les signatures
    const trainingAgreementData = {
      signatures: {
        participant: participantSignature,
        companySeal: companySeal,
        organizationSeal: organizationSeal,
        trainer: null,          // Peut √™tre d√©fini si n√©cessaire
        representative: null    // Peut √™tre d√©fini si n√©cessaire
      }
    };

    // Stockage dans une variable accessible aux autres effets
    // @ts-ignore - Nous d√©finissons la variable globalement pour qu'elle soit accessible aux autres effets
    window.trainingAgreement = trainingAgreementData;
    
    console.log('üîÑ [DEBUG] trainingAgreement mis √† jour:', trainingAgreementData);
  }, [participantSignature, companySeal, organizationSeal]);

  // Effet pour g√©rer l'insertion des tampons qui n'apparaissent pas correctement
  useEffect(() => {
    if (!companySeal && !organizationSeal) return;
    
    // Fonction de v√©rification avec limitation des tentatives
    const checkAndFixSeal = () => {
      // Limiter √† 2 tentatives maximum pour √©viter les boucles infinies
      if (sealAttemptsRef.current >= 2) {
        console.log('üîç [INFO] Nombre maximum de tentatives atteint pour corriger l\'affichage du tampon');
      return;
    }

      sealAttemptsRef.current++;
      
      if (companySeal) {
        const companySealDisplayed = document.querySelector('.company-seal img, [data-seal-container="company"] img');
        if (!companySealDisplayed) {
          console.log(`üîç [WARN] Le tampon n'est pas correctement affich√© apr√®s enregistrement (tentative ${sealAttemptsRef.current}/2)`);
          
          // Fonction interne pour forcer l'affichage du tampon
          const forceSealDisplay = () => {
            try {
              console.log('üîß [FORCE] Tentative de correction de l\'affichage du tampon');
              
              // Nettoyer l'URL et ajouter un unique param√®tre de timestamp
              const baseUrl = companySeal.split('?')[0];
              const timestamp = Date.now();
              const cleanSealUrl = `${baseUrl}?t=${timestamp}&forcereload=true`;
              
              console.log('üîß [FORCE] Nettoyage de l\'URL du tampon:', cleanSealUrl);
              
              // Pr√©charger l'image
              const img = new Image();
              img.onload = () => {
                console.log('‚úÖ [FORCE] Image du tampon pr√©charg√©e avec succ√®s, mise √† jour de l\'URL');
                
                safeSetCompanySeal(cleanSealUrl);
                // Mettre √† jour le cache global
                updateSignatureCache(participantSignature, cleanSealUrl, organizationSeal, trainerSignature);
                // Rafra√Æchir le composant
                setShouldRefresh(prev => !prev);
              };
              img.onerror = () => {
                console.error('‚ùå [FORCE] Erreur de pr√©chargement de l\'image du tampon');
              };
              img.src = cleanSealUrl;
            } catch (error) {
              console.error('‚ùå [FORCE] Erreur lors du for√ßage de l\'affichage du tampon:', error);
            }
          };
          
          forceSealDisplay();
        } else {
          console.log('‚úÖ [SUCCESS] Tampon correctement affich√© apr√®s correction');
        }
      }
    };
    
    // Une seule v√©rification apr√®s un d√©lai raisonnable
    const sealCheckTimeout = setTimeout(() => {
      checkAndFixSeal();
    }, 1500);
    
    // Nettoyage des timeouts lors du d√©montage du composant
    return () => {
      clearTimeout(sealCheckTimeout);
    };
  }, [companySeal, organizationSeal, safeSetCompanySeal, participantSignature, trainerSignature, updateSignatureCache]);

  // Corriger l'appel dans le useEffect de mise √† jour automatique du cache
  useEffect(() => {
    log('üîÑ', '[AUTO_CACHE]', 'Mise √† jour automatique du cache suite √† modification des signatures');
    updateSignatureCache(participantSignature, companySeal, organizationSeal, trainerSignature);
  }, [participantSignature, companySeal, organizationSeal, trainerSignature, updateSignatureCache]);

  // S'assurer que l'√©tat initial est correctement initialis√© √† partir du cache
  useEffect(() => {
    if (initialSignatures.participantSig || initialSignatures.companySeal || initialSignatures.trainerSig) {
      console.log('üîÑ [INIT] Initialisation des signatures depuis le cache:');
      
      if (initialSignatures.participantSig) {
        console.log('‚úÖ [INIT] Signature participant trouv√©e dans le cache');
        safeSetParticipantSignature(initialSignatures.participantSig);
        setIsSigned(true);
        setHasParticipantSignature(true);
      }
      
      if (initialSignatures.companySeal) {
        console.log('‚úÖ [INIT] Tampon entreprise trouv√© dans le cache');
        safeSetCompanySeal(initialSignatures.companySeal);
      }
      
      if (initialSignatures.organizationSeal) {
        console.log('‚úÖ [INIT] Tampon organisme trouv√© dans le cache');
        setOrganizationSeal(initialSignatures.organizationSeal);
      }
      
      if (initialSignatures.trainerSig) {
        console.log('‚úÖ [INIT] Signature formateur trouv√©e dans le cache');
        safeSetTrainerSignature(initialSignatures.trainerSig);
      }
      
      // D√©finir les signatures comme verrouill√©es pour √©viter les √©crasements accidentels
      setSignaturesLocked(true);
    }
  }, []);
  
  // Fonction pour sauvegarder une signature
  const handleSignatureSave = async (signatureDataUrl: string, type: 'participant' | 'companySeal' = 'participant') => {
    // V√©rifier l'authentification
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      alert('Vous devez √™tre connect√© pour signer ce document.');
      return;
    }
    
    if (isSaving) return;
    setIsSaving(true);
    
    // Emp√™cher la fermeture accidentelle de la page pendant l'enregistrement
    const preventUnload = (e: BeforeUnloadEvent) => {
      e.preventDefault();
      e.returnValue = 'Enregistrement en cours. √ätes-vous s√ªr de vouloir quitter?';
    };
    window.addEventListener('beforeunload', preventUnload);
    
    try {
      console.log(`üîç [SAVE] Sauvegarde du ${type === 'companySeal' ? 'tampon' : 'signature'} directement dans storage puis dans document_signatures`);
      
      try {
        // G√©n√©ration d'un nom unique pour le fichier de signature
        const timestamp = Date.now();
        const userId = participant.id;
        const trainingId = training.id;
        const signatureType = type;
        
        // Format: type_userId_trainingId_timestamp.png
        const fileName = `${signatureType}_${userId}_${trainingId}_${timestamp}.png`;
        
        console.log(`üîç [SAVE] Enregistrement du fichier dans storage avec nom: ${fileName}`);
        
        // 1. Enregistrer d'abord le fichier dans le bucket storage
        const { data: uploadData, error: uploadError } = await supabase.storage
          .from('signatures')
          .upload(fileName, 
            // Convertir le data URL en Blob
            await (await fetch(signatureDataUrl)).blob(), 
            { contentType: 'image/png', upsert: true });
        
        if (uploadError) {
          throw new Error(`Erreur lors de l'upload du fichier: ${uploadError.message}`);
        }
        
        console.log('‚úÖ [SAVE] Fichier enregistr√© avec succ√®s dans le bucket:', uploadData);
        
        // 2. R√©cup√©rer l'URL publique du fichier
        const { data: urlData } = await supabase.storage
          .from('signatures')
          .getPublicUrl(fileName);
        
        if (!urlData || !urlData.publicUrl) {
          throw new Error("Impossible d'obtenir l'URL publique du fichier");
        }
        
        const publicUrl = urlData.publicUrl;
        console.log('‚úÖ [SAVE] URL publique g√©n√©r√©e:', publicUrl);
        
        // 3. Enregistrer l'entr√©e dans document_signatures
        const { data: signatureData, error: signatureError } = await supabase
          .from('document_signatures')
          .insert([{
            user_id: participant.id,
            signature_url: publicUrl,
            signature_type: signatureType,
            training_id: training.id,
            type: 'convention',  // Type de document (convention, attestation, etc.)
            path: fileName,
            created_by: session.user.id
          }])
          .select();
        
        if (signatureError) {
          console.error('‚ùå [SAVE] Erreur lors de l\'enregistrement dans document_signatures:', signatureError);
          throw new Error(`Erreur lors de l'enregistrement dans document_signatures: ${signatureError.message}`);
        }
        
        console.log('‚úÖ [SAVE] Signature enregistr√©e dans document_signatures:', signatureData);
        
        // 4. Anticacher l'URL
        const antiCacheUrl = `${publicUrl.split('?')[0]}?t=${timestamp}&forcereload=true`;
        
        // 5. Pr√©charger l'image avant de mettre √† jour l'interface
        const img = new Image();
        img.onload = () => {
          console.log(`‚úÖ [SAVE] Image de ${type === 'companySeal' ? 'tampon' : 'signature'} pr√©charg√©e avec succ√®s`);
          
          // Mettre √† jour les √©tats selon le type
          if (type === 'companySeal') {
            safeSetCompanySeal(antiCacheUrl);
            
            // Notification pour le tampon
            toast.success('Tampon appliqu√© avec succ√®s !');
          } else {
            // Pour une signature normale de participant
            safeSetParticipantSignature(antiCacheUrl);
            setIsSigned(true);
            setHasParticipantSignature(true);
            
            // Mise √† jour du statut de signature dans la base de donn√©es
            try {
              console.log('üîÑ [SAVE] Mise √† jour du statut de signature dans user_profiles');
              supabase
                .from('user_profiles')
                .update({ has_signed_agreement: true })
                .eq('id', participant.id)
                .then(({ error }) => {
                  if (error) {
                    console.error('‚ùå [SAVE] Erreur lors de la mise √† jour du statut de signature:', error);
                  } else {
                    console.log('‚úÖ [SAVE] Statut de signature mis √† jour avec succ√®s');
                    toast.success('Convention sign√©e avec succ√®s !');
                  }
                });
            } catch (e) {
              console.error('‚ùå [SAVE] Erreur inattendue lors de la mise √† jour du statut:', e);
            }
          }
          
          // Mettre √† jour le cache global avec la nouvelle valeur
          updateSignatureCache(
            type === 'participant' ? antiCacheUrl : participantSignature,
            type === 'companySeal' ? antiCacheUrl : companySeal,
            organizationSeal,
            trainerSignature
          );
          
          // Fermer les canvas
          setShowSignatureCanvas(false);
          setShowSealCanvas(false);
          
          // Terminer le chargement et rafra√Æchir
          setIsSaving(false);
          setShouldRefresh(prev => !prev);
        };
        
        img.onerror = () => {
          console.error(`‚ùå [SAVE] Erreur de pr√©chargement de l'image de ${type === 'companySeal' ? 'tampon' : 'signature'}`);
          
          // Continuer malgr√© l'erreur
          if (type === 'companySeal') {
            safeSetCompanySeal(antiCacheUrl);
          } else {
            safeSetParticipantSignature(antiCacheUrl);
            setIsSigned(true);
          }
          
          // Mettre √† jour le cache global avec la nouvelle valeur
          updateSignatureCache(
            type === 'participant' ? antiCacheUrl : participantSignature,
            type === 'companySeal' ? antiCacheUrl : companySeal,
            organizationSeal,
            trainerSignature
          );
          
          setShowSignatureCanvas(false);
          setShowSealCanvas(false);
          setIsSaving(false);
          toast.error(`Le ${type === 'companySeal' ? 'tampon' : 'la signature'} a √©t√© enregistr√©, mais il pourrait y avoir un probl√®me d'affichage.`);
        };
        
        // D√©clencher le chargement
        img.src = antiCacheUrl;
        
      } catch (saveError) {
        console.error(`üîç [SAVE] Erreur lors de la sauvegarde:`, saveError);
        
        // Mode de secours: utiliser le dataURL local
        if (type === 'companySeal') {
          safeSetCompanySeal(signatureDataUrl);
        } else {
          safeSetParticipantSignature(signatureDataUrl);
          setIsSigned(true);
          setHasParticipantSignature(true);
        }
        
        // Mettre √† jour le cache global avec la valeur locale
        updateSignatureCache(
          type === 'participant' ? signatureDataUrl : participantSignature,
          type === 'companySeal' ? signatureDataUrl : companySeal,
          organizationSeal,
          trainerSignature
        );
        
        setShowSignatureCanvas(false);
        setShowSealCanvas(false);
        setIsSaving(false);
        toast.error(`Le ${type === 'companySeal' ? 'tampon' : 'la signature'} a √©t√© enregistr√© localement, mais n'a pas pu √™tre sauvegard√© sur le serveur.`);
      }
    } catch (error) {
      console.error(`‚ùå [SAVE] Erreur g√©n√©rale:`, error);
      toast.error(`Une erreur est survenue lors de la sauvegarde. Veuillez r√©essayer.`);
      setIsSaving(false);
    } finally {
      // Nettoyer l'√©v√©nement beforeunload
      window.removeEventListener('beforeunload', preventUnload);
    }
  };

  // Si un document existe d√©j√†, afficher un bouton pour le visualiser
  if (existingDocumentUrl && !isOnlyTrainerSignature && participantSignature) {
    return (
      <div className="fixed inset-0 bg-gray-900 bg-opacity-80 backdrop-blur-lg flex items-center justify-center z-50 p-4">
        <div className="bg-gray-800 rounded-xl shadow-2xl max-w-4xl w-full max-h-[90vh] flex flex-col">
          <div className="p-6 flex items-center justify-between border-b border-gray-700">
            <h2 className="text-xl font-semibold text-white">Convention de formation sign√©e</h2>
            <button
              onClick={onCancel}
              className="text-gray-400 hover:text-white transition-colors"
            >
              <X className="w-6 h-6" />
            </button>
          </div>
          
          <div className="p-6 overflow-y-auto flex-grow">
            {pdfLoading ? (
              <div className="flex flex-col items-center justify-center h-[70vh]">
                <div className="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-blue-500 mb-4"></div>
                <p className="text-white">Chargement du document...</p>
              </div>
            ) : pdfError ? (
              <div className="flex flex-col items-center justify-center h-[70vh] bg-gray-700 rounded-lg text-center p-8">
                <p className="text-white mb-4">Une erreur est survenue lors du chargement du document.</p>
                <p className="text-gray-300">Veuillez r√©essayer ult√©rieurement ou contacter le support.</p>
              </div>
            ) : (
              <iframe 
                src={documentUrl} 
                title="Convention de formation sign√©e" 
                className="w-full h-full min-h-[70vh] rounded-lg border border-gray-600"
                style={{ backgroundColor: 'white' }}
                onLoad={() => console.log('üîç [DEBUG] Document iframe loaded successfully (convention)')}
                onError={() => {
                  console.error('üîç [DEBUG] Error loading document iframe (convention)');
                  setPdfError(true);
                }}
              />
            )}
          </div>
          
          <div className="p-6 border-t border-gray-700 flex justify-end">
            <a
              href={documentUrl}
              target="_blank"
              rel="noopener noreferrer"
              download="convention_formation.pdf"
              className={`flex items-center gap-2 font-medium py-2 px-6 rounded-lg ${
                pdfLoading || pdfError
                  ? 'bg-gray-600 text-gray-300 cursor-not-allowed'
                  : 'bg-blue-600 hover:bg-blue-700 text-white'
              }`}
              onClick={(e) => {
                if (pdfLoading || pdfError) {
                  e.preventDefault();
                }
              }}
            >
              <Download className="w-5 h-5" /> T√©l√©charger la convention
            </a>
          </div>
        </div>
      </div>
    );
  }

  // Si le canvas de signature est affich√©
  if (showSignatureCanvas) {
    return (
      <div className="fixed inset-0 bg-gray-900 bg-opacity-80 backdrop-blur-lg flex items-center justify-center z-50 p-4">
        <div className="bg-gray-800 rounded-xl shadow-2xl max-w-4xl w-full flex flex-col">
          <div className="p-6 flex items-center justify-between border-b border-gray-700">
            <h2 className="text-xl font-semibold text-white">
              Signature de la convention
            </h2>
            <button
              onClick={() => setShowSignatureCanvas(false)}
              className="text-gray-400 hover:text-white transition-colors"
              disabled={isSaving}
            >
              <X className="w-6 h-6" />
            </button>
          </div>
          
          <div className="p-6">
            <h3 className="font-semibold text-lg mb-4">
              Apposez votre signature
            </h3>
            
            <div className="mb-8">
              <div className="border border-gray-300 rounded-lg">
                <SignatureCanvas
                  onSave={(dataURL) => {
                    handleSignatureComplete(dataURL);
                    // Enregistrer comme une signature normale
                    handleSignatureSave(dataURL);
                  }}
                  onCancel={() => setShowSignatureCanvas(false)}
                  isLoading={isSaving}
                  initialName={`${participant.first_name} ${participant.last_name}`}
                  signatureType="participant"
                />
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Si le canvas de tampon est affich√©
  if (showSealCanvas) {
    return (
      <div className="fixed inset-0 bg-gray-900 bg-opacity-80 backdrop-blur-lg flex items-center justify-center z-50 p-4">
        <div className="bg-gray-800 rounded-xl shadow-2xl max-w-4xl w-full flex flex-col">
          <div className="p-6 flex items-center justify-between border-b border-gray-700">
            <h2 className="text-xl font-semibold text-white">
              Tampon de l'entreprise
            </h2>
            <button
              onClick={() => setShowSealCanvas(false)}
              className="text-gray-400 hover:text-white transition-colors"
              disabled={isSaving}
            >
              <X className="w-6 h-6" />
            </button>
          </div>
          
          <div className="p-6">
            <h3 className="font-semibold text-lg mb-4">
              Apposez le tampon de votre entreprise
            </h3>
            
            <div className="mb-8">
              <div className="border border-gray-300 rounded-lg">
                <SignatureCanvas
                  onSave={(dataURL) => {
                    handleSignatureComplete(dataURL);
                    handleSignatureSave(dataURL, 'companySeal');
                  }}
                  onCancel={() => setShowSealCanvas(false)}
                  isLoading={isSaving}
                  signatureType="companySeal"
                />
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Affichage principale de la convention (avec ou sans signature)
  return (
    <div className="fixed inset-0 bg-gray-900 bg-opacity-80 backdrop-blur-lg flex items-center justify-center z-50 p-4">
      <div className="bg-gray-800 rounded-xl shadow-2xl max-w-4xl w-full max-h-[90vh] flex flex-col">
        <div className="p-6 flex items-center justify-between border-b border-gray-700">
          <h2 className="text-xl font-semibold text-white">
            {participantSignature ? "Convention de formation sign√©e" : "Convention de formation"}
            {participantSignature && <span className="ml-2 text-sm bg-green-600 text-white px-2 py-0.5 rounded-full">Sign√©e</span>}
          </h2>
          <button
            onClick={onCancel}
            className="text-gray-400 hover:text-white transition-colors"
          >
            <X className="w-6 h-6" />
          </button>
        </div>
        
        <div className="p-6 overflow-y-auto flex-grow">
          {/* PDF Content */}
          <div 
            ref={pdfContentRef} 
            className="bg-white text-black p-8 rounded-lg"
            style={{ fontFamily: 'Arial, Helvetica, sans-serif', fontSize: '14px' }}
          >
            {/* Affichage des d√©tails de l'entreprise avant rendu */}
            <div style={{ display: 'none' }}>
              {company ? <div>{`Debug: Entreprise ${company.name}`}</div> : null}
            </div>
            <div id="training-agreement-template">
              <UnifiedTrainingAgreementTemplate
                training={{
                  id: training.id,
                  title: training.title,
                  duration: training.duration,
                  location: training.location,
                  start_date: training.start_date,
                  end_date: training.end_date,
                  trainer_name: training.trainer_name,
                  trainer_details: training.trainer_id,
                  evaluation_methods: training.evaluation_methods,
                  tracking_methods: training.tracking_methods,
                  pedagogical_methods: training.pedagogical_methods,
                  material_elements: training.material_elements,
                  objectives: training.objectives,
                  content: training.content,
                  price: training.price
                }}
                company={company || { 
                  name: participant.company || '√Ä compl√©ter',
                  address: '√Ä compl√©ter',
                  postal_code: '',
                  city: '',
                  siret: '√Ä compl√©ter'
                }}
                participant={participant ? {
                  id: participant.id,
                  first_name: participant.first_name,
                  last_name: participant.last_name,
                  job_position: participant.job_position || '',
                  email: '',
                  company: participant.company
                } : undefined}
                participants={allTrainingParticipants.length > 0 
                  ? allTrainingParticipants 
                  : (participant ? [{
                      id: participant.id,
                      first_name: participant.first_name, 
                      last_name: participant.last_name,
                      job_position: participant.job_position || '',
                      email: '',
                      company: participant.company
                    }] : [])}
                participantSignature={participantSignature}
                companySeal={companySeal}
                organizationSeal={organizationSeal}
                viewContext="student"
                pdfMode={false}
                organizationSettings={organizationSettings || DEFAULT_ORGANIZATION_SETTINGS}
                trainerId={training.trainer_id}
                trainerSignature={trainerSignature}
              />
            </div>
          </div>
        </div>
        
        <div className="p-6 border-t border-gray-700 flex flex-wrap gap-3 justify-between">
          {!participantSignature ? (
            <div className="flex flex-wrap gap-3">
              <button
                onClick={() => setShowSignatureCanvas(true)}
                className="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-6 rounded-lg flex-grow md:flex-grow-0"
              >
                Signer la convention
              </button>
                
              {/* Ajout du bouton pour le tampon d'entreprise */}
              <button
                onClick={() => setShowSealCanvas(true)}
                className="bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-6 rounded-lg flex items-center justify-center gap-2"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <circle cx="12" cy="12" r="10"></circle>
                  <path d="M12 8v8"></path>
                  <path d="M8 12h8"></path>
                </svg>
                Ajouter un tampon
              </button>
            </div>
          ) : (
            <>
              {/* N'afficher le message de succ√®s que si has_signed_agreement est TRUE */}
              {participant.has_signed_agreement && (
                <div className="flex items-center text-green-400">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                  </svg>
                  Convention sign√©e avec succ√®s
                </div>
              )}
              
              {/* Toujours afficher les boutons de signature et tampon m√™me si d√©j√† sign√© */}
              <div className="flex flex-wrap gap-3">
                <button
                  onClick={() => setShowSignatureCanvas(true)}
                  className="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-6 rounded-lg flex-grow md:flex-grow-0"
                >
                  Signer la convention
                </button>
                <button
                  onClick={() => setShowSealCanvas(true)}
                  className="bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-6 rounded-lg flex items-center justify-center gap-2"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <path d="M12 8v8"></path>
                    <path d="M8 12h8"></path>
                  </svg>
                  Ajouter un tampon
                </button>
              </div>
            </>
          )}
          
          <div className="flex flex-wrap gap-3">
            {participantSignature && (
              <>
                <button
                  onClick={generatePDF}
                  className="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-6 rounded-lg flex items-center justify-center gap-2"
                  disabled={isGeneratingPDF}
                >
                  {isGeneratingPDF ? (
                    <>
                      <div className="animate-spin h-4 w-4 border-2 border-white border-t-transparent rounded-full"></div>
                      <span>G√©n√©ration...</span>
                    </>
                  ) : (
                    <>
                      <Download className="w-5 h-5" /> T√©l√©charger (sign√©)
                    </>
                  )}
                </button>
              </>
            )}
            
            <button
              onClick={generatePDF}
              className="bg-gray-700 hover:bg-gray-600 text-white font-medium py-2 px-6 rounded-lg flex items-center justify-center gap-2 flex-grow md:flex-grow-0"
            >
              <Download className="w-5 h-5" /> Visualiser PDF
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};