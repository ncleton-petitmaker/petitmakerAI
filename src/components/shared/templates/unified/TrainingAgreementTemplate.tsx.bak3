import React, { useRef, useEffect, useState, useMemo } from 'react';
import { format } from 'date-fns';
import { fr } from 'date-fns/locale';
import SafeImage, { loadOrganizationSealDirectly } from '../../../shared/SafeImage';
import { forceOrganizationSealInDOM } from '../../../../utils/SignatureUtils';
import { supabase } from '../../../../lib/supabase';
import { logDebug, logInfo, logError, logWarn, LOG_LEVELS } from '../../../../utils/LoggingUtils';
import { OrganizationSettings } from '../../DocumentUtils';

/**
 * Template unifi√© pour les conventions de formation
 * 
 * Ce template combine l'apparence simple du template standard avec les
 * fonctionnalit√©s avanc√©es de gestion de signature du template unifi√©.
 */

// Props standardis√©es pour le template unifi√©
export interface UnifiedTrainingAgreementTemplateProps {
  // Donn√©es du stagiaire - Modifi√© pour accepter un tableau de participants
  participants: Array<{
    id: string;
    first_name: string;
    last_name: string;
    job_position?: string;
    company?: string;
    email?: string;
    phone?: string;
    status?: string;
  }>;
  
  // Participant principal (pour r√©trocompatibilit√©)
  participant?: {
    id: string;
    first_name: string;
    last_name: string;
    job_position?: string;
    company?: string;
    email?: string;
    phone?: string;
    status?: string;
  };
  
  // Donn√©es de la formation
  training: {
    id: string;
    title: string;
    duration: string;
    trainer_name: string;
    trainer_details?: string;
    location: string;
    start_date: string | null;
    end_date: string | null;
    objectives?: string[];
    content?: string;
    price?: number | null;
    evaluation_methods?: {
      profile_evaluation?: boolean;
      skills_evaluation?: boolean;
      knowledge_evaluation?: boolean;
      satisfaction_survey?: boolean;
    };
    tracking_methods?: {
      attendance_sheet?: boolean;
      completion_certificate?: boolean;
    };
    pedagogical_methods?: {
      needs_evaluation?: boolean;
      theoretical_content?: boolean;
      practical_exercises?: boolean;
      case_studies?: boolean;
      experience_sharing?: boolean;
      digital_support?: boolean;
    };
    material_elements?: {
      computer_provided?: boolean;
      pedagogical_material?: boolean;
      digital_support_provided?: boolean;
    };
  };
  
  // Donn√©es de l'entreprise (optionnelles)
  company?: {
    name: string;
    address?: string;
    postal_code?: string;
    city?: string;
    country?: string;
    siret?: string;
    contact_name?: string;
    contact_email?: string;
    contact_phone?: string;
    isIndependent?: boolean;
  };
  
  // Param√®tres de l'organisme de formation
  organizationSettings: OrganizationSettings;
  
  // Donn√©es de signatures
  participantSignature?: string | null;
  representativeSignature?: string | null;
  trainerSignature?: string | null;
  companySeal?: string | null; // Tampon d'entreprise
  organizationSeal?: string | null; // Tampon de l'organisme de formation
  
  // Options d'affichage
  viewContext?: 'crm' | 'student' | 'admin' | 'generic';
  pdfMode?: boolean;
  
  // ID optionnel du formateur pour r√©cup√©ration de signature
  trainerId?: string;
  
  // Callbacks
  onRenderComplete?: () => void;
}

// D√©finition des param√®tres par d√©faut pour l'organisation
const DEFAULT_ORGANIZATION_SETTINGS: OrganizationSettings = {
  organization_name: 'PETITMAKER',
  address: '2 rue H√©racl√®s',
  siret: '928 386 044 00012',
  activity_declaration_number: '32 59 10753 59',
  representative_name: 'Nicolas Cleton',
  representative_title: 'Pr√©sident',
  city: 'Villeneuve-d\'Ascq',
  postal_code: '59650',
  country: 'France'
};

// Niveau de log actuel - modifier cette valeur pour voir plus ou moins de logs
const CURRENT_LOG_LEVEL = LOG_LEVELS.INFO; 

// Fonction pour d√©terminer si nous sommes en mode admin/crm
const isAdminOrCRM = () => {
  // V√©rifier si nous sommes en mode admin/CRM vs √©tudiant
  const isClientSide = typeof window !== 'undefined';
  if (!isClientSide) return true; // Par d√©faut en mode admin si SSR
  
  // V√©rifier l'URL pour d√©terminer si nous sommes en mode admin/CRM
  const path = window.location.pathname;
  const isAdmin = path.includes('/admin') || 
                path.includes('/crm') || 
                path.includes('/dashboard');
  return isAdmin;
};

// Fonction d'aide pour les logs conditionnels
const log = (level: number, type: string, message: string, data?: any) => {
  // Ne pas afficher les logs sauf si ce sont des erreurs critiques
  if (level > LOG_LEVELS.ERROR) {
    // V√©rifier si nous sommes en mode d√©veloppement
    if (process.env.NODE_ENV !== 'development') {
      return; // Ne rien faire en production sauf pour les erreurs
    }
  }
  
  // Continuer avec la logique de log normale
  if (level <= CURRENT_LOG_LEVEL) {
    if (data) {
      console.log(`${type} ${message}`, data);
    } else {
      console.log(`${type} ${message}`);
    }
  }
};

/**
 * Template unifi√© pour les conventions de formation
 */
export const UnifiedTrainingAgreementTemplate: React.FC<UnifiedTrainingAgreementTemplateProps> = ({
  participant,
  participants = [],
  training,
  company = { name: '' },
  organizationSettings = DEFAULT_ORGANIZATION_SETTINGS,
  participantSignature,
  representativeSignature,
  trainerSignature,
  companySeal,
  organizationSeal,
  viewContext = 'crm',
  pdfMode = false,
  trainerId,
  onRenderComplete
}) => {
  // Remplacer la fonction de log si on est en mode √©tudiant
  // Fonction de log qui ne fait rien (pour le mode √©tudiant)
  const noLog = () => {};
  
  // Utiliser une fonction qui ne fait rien en mode √©tudiant, sinon utiliser log normal
  const effectiveLog = viewContext === 'student' ? noLog : log;
  
  // S'assurer que nous avons toujours un tableau de participants
  const allParticipants = participants.length > 0 ? participants : (participant ? [participant] : []);
  
  // V√©rifier la valeur initiale de company avant toute utilisation
  effectiveLog(LOG_LEVELS.DEBUG, 'üö® [DEBUG]', 'Valeur initiale de company:', company);
  effectiveLog(LOG_LEVELS.DEBUG, 'üö® [DEBUG]', `Valeur par d√©faut appliqu√©e ?: ${company === null ? 'Oui (valeur par d√©faut)' : 'Non (company fourni)'}`);
  effectiveLog(LOG_LEVELS.DEBUG, 'üö® [DEBUG]', `Est-ce que company a une propri√©t√© name? ${company && typeof company === 'object' && 'name' in company}`);
  effectiveLog(LOG_LEVELS.DEBUG, 'üö® [DEBUG]', `Company isIndependent? ${company?.isIndependent === true ? 'Oui (ind√©pendant)' : 'Non (entreprise standard)'}`);
  effectiveLog(LOG_LEVELS.DEBUG, 'üö® [DEBUG]', `Nombre de participants: ${allParticipants.length}`);
  
  const documentRef = useRef<HTMLDivElement>(null);
  const [signaturesInitialized, setSignaturesInitialized] = useState(false);

  // √âtat pour suivre les signatures et tampons d√©j√† charg√©s avec succ√®s
  const [loadedSignatures, setLoadedSignatures] = useState<{
    participantSig: boolean;
    representativeSig: boolean;
    trainerSig: boolean;
    companySeal: boolean;
    organizationSeal: boolean;
  }>({
    participantSig: false,
    representativeSig: false,
    trainerSig: false,
    companySeal: false,
    organizationSeal: false
  });

  // √âtat global pour m√©moriser les URLs de tampons d√©j√† charg√©s
  const [sealURLCache, setSealURLCache] = useState<{
    companySeal: string | null;
    organizationSeal: string | null;
  }>({
    companySeal: null,
    organizationSeal: null
  });

  // Fonction pour marquer une signature comme charg√©e
  const markSignatureAsLoaded = (type: 'participantSig' | 'representativeSig' | 'trainerSig' | 'companySeal' | 'organizationSeal') => {
    setLoadedSignatures(prev => ({
      ...prev,
      [type]: true
    }));
    log(LOG_LEVELS.INFO, 'üîí [CHARGEMENT]', `Signature/tampon de type ${type} marqu√©(e) comme charg√©(e)`);
  };

  // NOUVEAU: Hook pour forcer la r√©cup√©ration de la signature formateur c√¥t√© apprenant
  useEffect(() => {
    // Variable pour suivre si la signature a d√©j√† √©t√© trouv√©e
    let signatureFound = false;
    
    const initializeTrainerSignature = async () => {
      // Uniquement si on est en vue √©tudiant, sans signature de formateur et pas en mode PDF
      if (viewContext === 'student' && !trainerSignature && !pdfMode && !signatureFound) {
        log(LOG_LEVELS.DEBUG, 'üÜï [TRAINER_FIX]', 'Tentative de r√©cup√©ration de la signature formateur c√¥t√© √©tudiant');
        
        try {
          // 0. Si on a un ID de formateur, l'utiliser en priorit√©
          if (trainerId) {
            log(LOG_LEVELS.DEBUG, 'üÜï [TRAINER_FIX]', 'Recherche avec ID formateur:', trainerId);
            
            // Rechercher dans document_signatures sp√©cifiquement pour ce formateur
            const { data: trainerUserSigData, error: userSigError } = await supabase
              .from('document_signatures')
              .select('signature_url')
              .eq('user_id', trainerId)
              .eq('signature_type', 'trainer')
              .order('created_at', { ascending: false })
              .limit(1);
              
            if (!userSigError && trainerUserSigData && trainerUserSigData.length > 0 && trainerUserSigData[0].signature_url) {
              log(LOG_LEVELS.DEBUG, 'üÜï [TRAINER_FIX]', 'Signature trouv√©e via ID formateur:', trainerUserSigData[0].signature_url);
              signatureFound = true;
              injectTrainerSignature(trainerUserSigData[0].signature_url);
              return;
            }
          }
          
          // 1. Premi√®re m√©thode: Rechercher dans document_signatures avec le format trainer_convention_ + ID
          const { data: trainerSigData, error: sigError } = await supabase
            .from('document_signatures')
            .select('signature_url')
            .eq('training_id', training.id)
            .eq('type', 'convention')
            .eq('signature_type', 'trainer')
            .order('created_at', { ascending: false })
            .limit(1);
            
          // Si on trouve avec cette m√©thode, on utilise cette signature
          if (!sigError && trainerSigData && trainerSigData.length > 0 && trainerSigData[0].signature_url) {
            log(LOG_LEVELS.DEBUG, 'üÜï [TRAINER_FIX]', 'Signature formateur trouv√©e dans document_signatures:', trainerSigData[0].signature_url);
            signatureFound = true;
            injectTrainerSignature(trainerSigData[0].signature_url);
            return; // On arr√™te ici si on a trouv√©
          }
          
          // 2. Deuxi√®me m√©thode: Rechercher les objets dans le bucket signatures avec le pr√©fixe "trainer_convention_"
          const { data: storageFiles, error: storageError } = await supabase.storage
            .from('signatures')
            .list('', { 
              search: `trainer_convention_${training.id}`,
              sortBy: { column: 'created_at', order: 'desc' }
            });
            
          if (!storageError && storageFiles && storageFiles.length > 0) {
            const sigFile = storageFiles[0];
            // G√©n√©rer l'URL du fichier trouv√©
            const { data: urlData } = await supabase.storage
              .from('signatures')
              .getPublicUrl(sigFile.name);
              
            if (urlData && urlData.publicUrl) {
              log(LOG_LEVELS.DEBUG, 'üÜï [TRAINER_FIX]', 'Signature formateur trouv√©e dans le bucket:', urlData.publicUrl);
              signatureFound = true;
              injectTrainerSignature(urlData.publicUrl);
              return; // On arr√™te ici si on a trouv√©
            }
          }
          
          // 3. M√©thode existante: Rechercher dans la table documents
          const { data: trainerDocs, error } = await supabase
            .from('documents')
            .select('file_url')
            .eq('title', "Signature du formateur")
            .eq('training_id', training.id)
            .eq('type', 'convention')
            .order('created_at', { ascending: false })
            .limit(1);
          
          if (error) {
            log(LOG_LEVELS.ERROR, 'üÜï [TRAINER_FIX]', 'Erreur lors de la recherche de signature formateur:', error);
          } else if (trainerDocs && trainerDocs.length > 0 && trainerDocs[0].file_url) {
            log(LOG_LEVELS.DEBUG, 'üÜï [TRAINER_FIX]', 'Signature formateur trouv√©e dans la base documents:', trainerDocs[0].file_url);
            signatureFound = true;
            injectTrainerSignature(trainerDocs[0].file_url);
          } else {
            log(LOG_LEVELS.DEBUG, 'üÜï [TRAINER_FIX]', 'Aucune signature formateur trouv√©e dans aucune source');
          }
        } catch (error) {
          log(LOG_LEVELS.ERROR, 'üÜï [TRAINER_FIX]', 'Erreur lors de la r√©cup√©ration de la signature formateur:', error);
        }
      }
    };
    
    // Fonction pour injecter la signature dans le DOM
    const injectTrainerSignature = (signatureUrl: string) => {
      log(LOG_LEVELS.INFO, 'üñäÔ∏è [TRAINER_SIG]', 'Injection de la signature du formateur:', signatureUrl);
      
      try {
        // 1. Trouver l'√©l√©ment img pour la signature du formateur
        const signatureImg = document.querySelector('#trainer-signature-img') as HTMLImageElement;
        if (signatureImg) {
          // Sauvegarder les valeurs pr√©c√©dentes
          const previousSrc = signatureImg.src;
          const previousDisplay = signatureImg.style.display;
          
          // D√©finir la nouvelle source
          signatureImg.src = signatureUrl;
          signatureImg.style.display = 'block';
          
          // Ajouter un gestionnaire d'erreur
          signatureImg.onerror = () => {
            log(LOG_LEVELS.ERROR, 'üñäÔ∏è [TRAINER_SIG]', 'Erreur lors du chargement de la signature:', signatureUrl);
            // Restaurer les valeurs pr√©c√©dentes
            signatureImg.src = previousSrc;
            signatureImg.style.display = previousDisplay;
          };
          
          // Ajouter un gestionnaire de chargement r√©ussi
          signatureImg.onload = () => {
            log(LOG_LEVELS.INFO, 'üñäÔ∏è [TRAINER_SIG]', 'Signature charg√©e avec succ√®s');
            
            // Force un minimum de taille visible
            signatureImg.style.minWidth = '100px';
            signatureImg.style.minHeight = '30px';
            
            // Force le parent √† √™tre visible
            const parentElement = signatureImg.parentElement;
            if (parentElement) {
              parentElement.style.display = 'block';
              parentElement.style.visibility = 'visible';
            }
          };
          
          // Forcer la visibilit√© de tous les parents
          let parent: HTMLElement | null = signatureImg.parentElement;
          while (parent) {
            // Rendre visible chaque parent
            parent.style.display = 'block';
            parent.style.visibility = 'visible';
            
            // Remonter au parent suivant
            parent = parent.parentElement;
          }
          
          log(LOG_LEVELS.INFO, 'üñäÔ∏è [TRAINER_SIG]', 'Signature du formateur inject√©e avec succ√®s');
          return true;
        } else {
          log(LOG_LEVELS.ERROR, 'üñäÔ∏è [TRAINER_SIG]', '√âl√©ment de signature du formateur non trouv√©');
          return false;
        }
      } catch (error) {
        log(LOG_LEVELS.ERROR, 'üñäÔ∏è [TRAINER_SIG]', 'Erreur lors de l\'injection de la signature:', error);
        return false;
      }
    };
    
    // Ex√©cuter apr√®s un petit d√©lai pour laisser le reste du composant s'initialiser
    const timer = setTimeout(initializeTrainerSignature, 500);
    return () => clearTimeout(timer);
  }, [viewContext, trainerSignature, pdfMode, training.id, trainerId]);

  // NOUVEAU: Hook pour forcer la r√©cup√©ration du tampon d'organisme c√¥t√© apprenant
  useEffect(() => {
    // Variable pour suivre si le tampon a d√©j√† √©t√© trouv√©
    let sealFound = false;
    
    const initializeOrganizationSeal = async () => {
      // Uniquement si on est en vue √©tudiant, sans tampon d'organisation et pas en mode PDF
      if (viewContext === 'student' && !organizationSeal && !pdfMode) {
        log(LOG_LEVELS.DEBUG, 'üîé [ORG_SEAL]', 'Tentative de r√©cup√©ration du tampon d\'organisme c√¥t√© √©tudiant');
        
        try {
          // Essayer via la fonction loadOrganizationSealDirectly du composant SafeImage
          const directSealUrl = await loadOrganizationSealDirectly();
          if (directSealUrl) {
            log(LOG_LEVELS.DEBUG, '‚úÖ [ORG_SEAL]', 'Tampon trouv√© via loadOrganizationSealDirectly:', directSealUrl);
            
            // Mise √† jour directe du DOM
            const sealImg = document.querySelector('#organization-seal-img') as HTMLImageElement;
            if (sealImg) {
              log(LOG_LEVELS.INFO, '‚úÖ [ORG_SEAL]', 'Mise √† jour directe du DOM avec le tampon d\'organisme');
              sealImg.src = directSealUrl;
              sealImg.style.display = 'block';
            } else {
              log(LOG_LEVELS.WARN, '‚ö†Ô∏è [ORG_SEAL]', '√âl√©ment #organization-seal-img non trouv√© dans le DOM');
            }
          } else {
            log(LOG_LEVELS.WARN, '‚ö†Ô∏è [ORG_SEAL]', 'Aucun tampon d\'organisme trouv√©');
          }
        } catch (error) {
          log(LOG_LEVELS.ERROR, '‚ùå [ORG_SEAL]', 'Erreur lors de la r√©cup√©ration du tampon d\'organisme:', error);
        }
      }
    };
    
    // Fonction pour injecter le tampon dans le DOM
    const injectOrganizationSeal = (sealUrl: string) => {
      log(LOG_LEVELS.INFO, 'üîÑ [INJECTION_SEAL]', 'Injection du tampon d\'organisme:', sealUrl);
      
      try {
        // 1. Trouver l'√©l√©ment img avec l'ID organization-seal-img
        const sealImgElement = document.querySelector('#organization-seal-img') as HTMLImageElement;
        if (sealImgElement) {
          // Sauvegarder les valeurs pr√©c√©dentes
          const previousSrc = sealImgElement.src;
          const previousDisplay = sealImgElement.style.display;
          
          // D√©finir la nouvelle source
          sealImgElement.src = sealUrl;
          sealImgElement.style.display = 'block';
          sealImgElement.setAttribute('alt', 'Tampon de l\'organisme de formation');
          
          // Ajouter un gestionnaire d'erreur au cas o√π l'image ne se charge pas
          sealImgElement.onerror = () => {
            log(LOG_LEVELS.ERROR, 'üîÑ [INJECTION_SEAL]', 'Erreur lors du chargement du tampon:', sealUrl);
            // Restaurer les valeurs pr√©c√©dentes
            sealImgElement.src = previousSrc;
            sealImgElement.style.display = previousDisplay;
          };
          
          // Ajouter un gestionnaire de chargement r√©ussi
          sealImgElement.onload = () => {
            log(LOG_LEVELS.INFO, 'üîÑ [INJECTION_SEAL]', 'Tampon charg√© avec succ√®s');
            
            // Force un minimum de taille visible
            sealImgElement.style.minWidth = '100px';
            sealImgElement.style.minHeight = '100px';
            
            // Force le parent √† √™tre visible
            const parentElement = sealImgElement.parentElement;
            if (parentElement) {
              parentElement.style.display = 'block';
              parentElement.style.visibility = 'visible';
            }
          };
          
          // Forcer la visibilit√© de tous les parents
          let parent: HTMLElement | null = sealImgElement.parentElement;
          while (parent) {
            // Rendre visible chaque parent
            parent.style.display = 'block';
            parent.style.visibility = 'visible';
            
            // Remonter au parent suivant
            parent = parent.parentElement;
          }
          
          log(LOG_LEVELS.INFO, 'üîÑ [INJECTION_SEAL]', 'Tampon d\'organisme inject√© avec succ√®s');
          return true;
        } else {
          log(LOG_LEVELS.ERROR, 'üîÑ [INJECTION_SEAL]', '√âl√©ment #organization-seal-img non trouv√©');
          return false;
        }
      } catch (error) {
        log(LOG_LEVELS.ERROR, 'üîÑ [INJECTION_SEAL]', 'Erreur lors de l\'injection du tampon:', error);
        return false;
      }
    };
    
    // Ex√©cuter apr√®s un petit d√©lai pour laisser le reste du composant s'initialiser
    const timer = setTimeout(initializeOrganizationSeal, 500);
    return () => clearTimeout(timer);
  }, [viewContext, organizationSeal, pdfMode]);

  // CORRECTION: V√©rifier explicitement que les valeurs sont correctes
  // S'assurer que les URL de signatures et tampons sont du bon type et non m√©lang√©s
  const validateSignatures = () => {
    if (companySeal && companySeal.includes('participant_convention')) {
      log(LOG_LEVELS.ERROR, '‚ö†Ô∏è [CORRECTION]', 'D√©tection d\'un probl√®me: companySeal contient une r√©f√©rence √† participant');
    }

    if (organizationSeal && organizationSeal.includes('participant_convention')) {
      log(LOG_LEVELS.ERROR, '‚ö†Ô∏è [CORRECTION]', 'D√©tection d\'un probl√®me: organizationSeal contient une r√©f√©rence √† participant');
    }
    
    if (trainerSignature && trainerSignature.includes('participant_convention')) {
      log(LOG_LEVELS.ERROR, '‚ö†Ô∏è [CORRECTION]', 'D√©tection d\'un probl√®me: trainerSignature contient une r√©f√©rence √† participant');
    }
    
    // V√©rifier les URL pour confirmer les types
    if (trainerSignature) {
      log(LOG_LEVELS.INFO, 'üîé [VERIFICATION]', 'URL de la signature formateur:', trainerSignature);
    }
    if (representativeSignature) {
      log(LOG_LEVELS.INFO, 'üîé [VERIFICATION]', 'URL de la signature repr√©sentant:', representativeSignature);
    }
    if (participantSignature) {
      log(LOG_LEVELS.INFO, 'üîé [VERIFICATION]', 'URL de la signature participant:', participantSignature);
    }
    if (companySeal) {
      log(LOG_LEVELS.INFO, 'üîé [VERIFICATION]', 'URL du tampon entreprise:', companySeal);
    }
    if (organizationSeal) {
      log(LOG_LEVELS.INFO, 'üîé [VERIFICATION]', 'URL du tampon organisme:', organizationSeal);
    }
  };

  // V√©rifier les signatures au chargement
  useEffect(() => {
    validateSignatures();
  }, [participantSignature, representativeSignature, trainerSignature, companySeal, organizationSeal]);

  // Fonction pour valider une URL de tampon
  const validateSealURL = (url: string | null): string | null => {
    if (!url) {
      return null;
    }
    
    // S'assurer que c'est une cha√Æne
    if (typeof url !== 'string') {
      log(LOG_LEVELS.WARN, 'üö® [VALIDATION]', 'URL de tampon invalide (type non-string)', typeof url);
      return null;
    }
    
    try {
      // Extraire l'URL de base sans les param√®tres de requ√™te pour √©viter les probl√®mes avec des URLs tr√®s longues
      const baseUrl = url.split('?')[0];
      
      // V√©rifier si c'est une URL valide
      const parsedUrl = new URL(baseUrl);
      
      // V√©rifier si c'est un tampon stock√© dans le sous-dossier 'seals/' ou avec le type 'companySeal' ou 'organizationSeal'
      const isSealInSealsFolder = parsedUrl.pathname.includes('/seals/');
      const isSealInOrganizationSeals = parsedUrl.pathname.includes('/organization-seals/') || 
                                      parsedUrl.pathname.includes('/organization_seal_');
      const isSealByType = 
        parsedUrl.pathname.includes('companySeal_') || 
        parsedUrl.pathname.includes('seal_company_convention') ||
        parsedUrl.pathname.includes('organizationSeal_') || 
        parsedUrl.pathname.includes('seal_organization_convention');
      
      // Accepter √©galement les URLs qui contiennent 'signatures' et 'organization_seal'
      const isOrganizationSealInRoot = parsedUrl.pathname.includes('/signatures/organization_seal_');
      
      // Si c'est un tampon mais qu'il n'est pas dans le bon dossier, √©mettre un avertissement
      if (!isSealInSealsFolder && !isSealInOrganizationSeals && (isSealByType || isOrganizationSealInRoot)) {
        log(LOG_LEVELS.DEBUG, 'üö® [VALIDATION]', 'URL de tampon sans chemin /seals/ ou /organization-seals/:', baseUrl);
        // On accepte quand m√™me car c'est un tampon
      }
      
      if (isSealInSealsFolder || isSealInOrganizationSeals || isSealByType || isOrganizationSealInRoot) {
        log(LOG_LEVELS.INFO, '‚úÖ [VALIDATION]', 'URL de tampon valide:', baseUrl);
        return url;
      }
      
      // Si l'URL contient "participant_convention", ce n'est probablement pas un tampon
      if (baseUrl.includes('participant_convention')) {
        log(LOG_LEVELS.ERROR, '‚ùå [VALIDATION]', 'URL qui semble √™tre une signature incorrectement assign√©e comme tampon:', baseUrl);
        return null;
      }
      
      log(LOG_LEVELS.DEBUG, 'üö® [VALIDATION]', 'URL qui ne semble pas √™tre un tampon (mais accept√©e):', baseUrl);
      // Si c'est une URL mais qui ne semble pas √™tre un tampon, on accepte quand m√™me
      // car cela pourrait √™tre un tampon import√© d'ailleurs
      return url;
    } catch (error) {
      log(LOG_LEVELS.WARN, 'üö® [VALIDATION]', 'URL de tampon invalide (erreur de parsing):', { url, error });
      // Si ce n'est pas une URL valide, retourner null
      return null;
    }
  };

  // CORRECTION MAJEURE: S'assurer que les signatures sont bien distinctes
  // Pour assurer que le tampon de l'organisme n'est pas remplac√© par une signature
  const safeOrganizationSeal = validateSealURL(organizationSeal || null);
    
  // Pour assurer que le tampon de l'entreprise n'est pas remplac√© par une signature
  const safeCompanySeal = validateSealURL(companySeal || null);
    
  // S'assurer que la signature du formateur n'est pas une signature de participant ni un tampon
  // MODIFICATION MAJEURE: Ne JAMAIS utiliser representativeSignature comme fallback
  const safeTrainerSignature = trainerSignature &&
    !trainerSignature.includes('participant_convention') &&
    !trainerSignature.includes('representative_convention') && // Ajout pour √©viter la confusion avec le repr√©sentant
    !trainerSignature.includes('seal_company_convention') &&
    !trainerSignature.includes('companySeal') ?
    trainerSignature : null; // Jamais de fallback vers representativeSignature

  // Pour la signature d'entreprise, s'assurer qu'on utilise bien la signature du participant
  const safeParticipantSignature = participantSignature || null;
    
  // Utiliser une signature effective pour le formateur, JAMAIS celle du repr√©sentant
  const effectiveTrainerSignature = safeTrainerSignature;

  // Fonction pour valider la signature du formateur
  const isValidTrainerSignature = (url: string | null | undefined): boolean => {
    if (!url) return false;
    return !url.includes('seal_company_convention') && 
           !url.includes('companySeal') && 
           !url.includes('seal_organization_convention') && 
           !url.includes('organizationSeal');
  };
  
  // Double v√©rification pour s'assurer qu'on n'utilise pas un tampon comme signature
  const isSignatureURL = (url: string | null): boolean => {
    if (!url) return false;
    return url.includes('signatures/');
  };
  
  const isSealURL = (url: string | null): boolean => {
    if (!url) return false;
    
    // Extraire l'URL de base sans les param√®tres de requ√™te
    const baseUrl = url.split('?')[0];
    
    // Log pour v√©rifier l'URL exacte qui est v√©rifi√©e
    log(LOG_LEVELS.INFO, 'üîç [VERIFICATION_URL]', 'V√©rification si URL est un tampon:', baseUrl);
    
    // Ajout de conditions plus larges pour accepter les tampons d'organisation
    return baseUrl.includes('seals/') || 
           baseUrl.includes('companySeal_') || 
           baseUrl.includes('seal_company_convention') ||
           baseUrl.includes('organizationSeal_') || 
           baseUrl.includes('organization_seal') ||
           baseUrl.includes('seal_organization_convention') ||
           baseUrl.includes('/organization-seals/') ||
           baseUrl.includes('/organization_seal_') ||
           // Ajouter cette condition pour accepter les tampons d'organisation stock√©s directement dans signatures/
           (baseUrl.includes('signatures/') && (
             baseUrl.includes('organization') || 
             baseUrl.includes('tampon_org') || 
             baseUrl.includes('org_seal')
           ));
  };
  
  // Logs de v√©rification
  log(LOG_LEVELS.INFO, 'üîç [VERIFICATION_FINALE]', 'URL signatures et tampons:', JSON.stringify({
    participant: {
      original: participantSignature,
      safe: safeParticipantSignature,
      isSignature: participantSignature ? isSignatureURL(participantSignature) : false,
      isSeal: participantSignature ? isSealURL(participantSignature) : false
    },
    trainer: {
      original: trainerSignature, 
      safe: safeTrainerSignature,
      effectiveTrainer: effectiveTrainerSignature,
      isSignature: trainerSignature ? isSignatureURL(trainerSignature) : false,
      isSeal: trainerSignature ? isSealURL(trainerSignature) : false
    },
    companySeal: {
      original: companySeal,
      safe: safeCompanySeal,
      isSignature: companySeal ? isSignatureURL(companySeal) : false,
      isSeal: companySeal ? isSealURL(companySeal) : false
    },
    organizationSeal: {
      original: organizationSeal,
      safe: safeOrganizationSeal,
      isSignature: organizationSeal ? isSignatureURL(organizationSeal) : false,
      isSeal: organizationSeal ? isSealURL(organizationSeal) : false
    }
  }));
  
  log(LOG_LEVELS.INFO, 'üîß [CORRECTION]', 'Signatures finales apr√®s validation:', JSON.stringify({
    participantSig: !!participantSignature,
    representativeSig: !!representativeSignature,
    trainerSig: !!trainerSignature,
    effectiveTrainerSig: !!effectiveTrainerSignature,
    companySeal: !!companySeal,
    safeCompanySeal: !!safeCompanySeal,
    organizationSeal: !!organizationSeal,
    safeOrganizationSeal: !!safeOrganizationSeal
  }));
    
  useEffect(() => {
    log(LOG_LEVELS.INFO, 'üìÇ [DEBUG]', 'UnifiedTrainingAgreementTemplate charg√©');
    log(LOG_LEVELS.DEBUG, 'üìÇ [DEBUG]', 'Donn√©es participant et entreprise', JSON.stringify({ 
      company, 
      participant, 
      signatures: {
        participant: participantSignature ? 'Pr√©sente' : 'Absente',
        representative: representativeSignature ? 'Pr√©sente' : 'Absente', 
        trainer: trainerSignature ? 'Pr√©sente' : 'Absente',
        companySeal: companySeal ? 'Pr√©sent' : 'Absent',
        organizationSeal: organizationSeal ? 'Pr√©sent' : 'Absent'
      }
    }));
    
    // Log d√©taill√© des donn√©es participant
    log(LOG_LEVELS.DEBUG, 'üìÇ [DEBUG] Donn√©es compl√®tes du participant:', JSON.stringify({
      id: participant?.id,
      name: `${participant?.first_name} ${participant?.last_name}`,
      email: participant?.email || 'Non sp√©cifi√©',
      job_position: participant?.job_position || 'Non sp√©cifi√©',
      status: participant?.status || 'Non sp√©cifi√©',
      company: participant?.company || 'Non sp√©cifi√©'
    }));
    
    // V√©rifier signatures disponibles
    log(LOG_LEVELS.INFO, 'üìÇ [DEBUG] Signatures disponibles:', JSON.stringify({
      participant: participantSignature ? 'Oui' : 'Non',
      representative: representativeSignature ? 'Oui' : 'Non', 
      trainer: trainerSignature ? 'Oui' : 'Non',
      companySeal: companySeal ? 'Oui' : 'Non'
    }));
    
    // Appliquer l'initialisation des signatures apr√®s un d√©lai
    const timer = setTimeout(() => {
      setSignaturesInitialized(true);
    }, 300);
    
    // Notifier quand le composant est pr√™t
    if (onRenderComplete) {
      setTimeout(() => {
        onRenderComplete();
      }, 500);
    }
    
    return () => clearTimeout(timer);
  }, [onRenderComplete, company, participant?.company]);

  // Log des valeurs de signature pour d√©bogage
  useEffect(() => {
    log(LOG_LEVELS.INFO, 'üîç [DEBUG]', 'TrainingAgreementTemplate - Tampons et signatures re√ßus:', JSON.stringify({
      participantSignature: participantSignature ? "PR√âSENTE" : "ABSENTE",
      representativeSignature: representativeSignature ? "PR√âSENTE" : "ABSENTE",
      trainerSignature: trainerSignature ? "PR√âSENTE" : "ABSENTE",
      companySeal: companySeal ? "PR√âSENT" : "ABSENT",
      organizationSeal: organizationSeal ? "PR√âSENT" : "ABSENT"
    }));
    
    if (organizationSeal) {
      log(LOG_LEVELS.INFO, '‚úÖ [DEBUG]', 'Tampon de l\'organisme URL:', organizationSeal);
    }
  }, [participantSignature, representativeSignature, trainerSignature, companySeal, organizationSeal]);

  // Formatage des dates
  const formatDate = (dateString: string | null) => {
    if (!dateString) return '';
    try {
      const date = new Date(dateString);
      return format(date, 'dd/MM/yyyy', { locale: fr });
    } catch (e) {
      log(LOG_LEVELS.ERROR, '‚ùå [DATE]', `Erreur de formatage de date: ${String(e)}`);
      return dateString;
    }
  };

  // Dates de formation
  const getTrainingDates = () => {
    const startDate = formatDate(training.start_date);
    const endDate = formatDate(training.end_date);
    
    if (startDate && endDate && startDate !== endDate) {
      return `du ${startDate} au ${endDate}`;
    } else if (startDate) {
      return `le ${startDate}`;
    } else {
      return 'Dates √† d√©finir';
    }
  };
  
  // Obtenir les objectifs de formation
  const getObjectives = () => {
    if (Array.isArray(training.objectives) && training.objectives.length > 0) {
      return training.objectives;
    }
    return ['Objectifs √† d√©finir'];
  };

  // M√©thodes d'√©valuation
  const getEvaluationMethods = () => {
    const methods = [];
    
    if (training.evaluation_methods?.profile_evaluation) methods.push("√âvaluation du profil avant formation");
    if (training.evaluation_methods?.skills_evaluation) methods.push("√âvaluation des comp√©tences acquises");
    if (training.evaluation_methods?.knowledge_evaluation) methods.push("√âvaluation des connaissances");
    if (training.evaluation_methods?.satisfaction_survey) methods.push("Questionnaire de satisfaction");
    
    return methods.length > 0 ? methods : ["√âvaluation √† d√©finir"];
  };

  // M√©thodes p√©dagogiques
  const getPedagogicalMethods = () => {
    const methods = [];
    
    if (training.pedagogical_methods?.needs_evaluation) methods.push("√âvaluation des besoins");
    if (training.pedagogical_methods?.theoretical_content) methods.push("Apports th√©oriques");
    if (training.pedagogical_methods?.practical_exercises) methods.push("Exercices pratiques");
    if (training.pedagogical_methods?.case_studies) methods.push("√âtudes de cas");
    if (training.pedagogical_methods?.experience_sharing) methods.push("Partage d'exp√©rience");
    if (training.pedagogical_methods?.digital_support) methods.push("Support de cours num√©rique");
    
    return methods.length > 0 ? methods : ["M√©thodes p√©dagogiques √† d√©finir"];
  };

  // √âl√©ments mat√©riels
  const getMaterialElements = () => {
    const elements = [];
    
    if (training.material_elements?.computer_provided) elements.push("Ordinateur fourni");
    if (training.material_elements?.pedagogical_material) elements.push("Mat√©riel p√©dagogique");
    if (training.material_elements?.digital_support_provided) elements.push("Support de cours au format num√©rique");
    
    return elements.length > 0 ? elements : ["√âl√©ments mat√©riels √† d√©finir"];
  };
  
  // Fonction pour ajouter un param√®tre anti-cache aux URLs d'images
  const getAntiCacheSignatureUrl = (url: string, isForSeal: boolean = false): string => {
    if (!url) return '';
    
    // Si l'URL est d√©j√† dans le cache de tampons et qu'il s'agit d'un tampon, utiliser la version en cache
    if (isForSeal) {
      if (sealURLCache.companySeal && url.includes(sealURLCache.companySeal.split('?')[0])) {
        log(LOG_LEVELS.INFO, 'üîí [ANTI_CACHE]', 'Utilisation de l\'URL en cache pour le tampon entreprise');
        return sealURLCache.companySeal;
      }
      if (sealURLCache.organizationSeal && url.includes(sealURLCache.organizationSeal.split('?')[0])) {
        log(LOG_LEVELS.INFO, 'üîí [ANTI_CACHE]', 'Utilisation de l\'URL en cache pour le tampon organisme');
        return sealURLCache.organizationSeal;
      }
    }
    
    // V√©rifier si c'est une URL
    try {
      const parsedUrl = new URL(url);
      
      // Ajouter un param√®tre de timestamp pour √©viter la mise en cache
      const timestamp = new Date().toISOString().replace(/[^0-9]/g, '');
      
      // Si c'est une URL de tampon (dans le dossier seals/) et qu'on n'a pas encore de version en cache
      if (isForSeal && (url.includes('/seals/') || url.includes('seal_company_convention') || url.includes('seal_organization_convention'))) {
        // Pour les tampons, utiliser un param√®tre plus stable (sans forcereload)
        return `${url}?t=${timestamp}&anticache=seal`;
      }
      
      // Pour les autres signatures, ajouter simplement un timestamp
      return `${url}?t=${timestamp}`;
    } catch (e) {
      // Si ce n'est pas une URL valide, retourner telle quelle
      log(LOG_LEVELS.WARN, 'üîç [DEBUG]', 'URL invalide pour getAntiCacheSignatureUrl:', url);
      return url;
    }
  };

  // Fonction pour formater le prix
  const formatPrice = (price: number | null | undefined): string => {
    if (price === null || price === undefined) return 'Sur devis';
    return new Intl.NumberFormat('fr-FR', { style: 'currency', currency: 'EUR' }).format(price);
  };

  // R√©cup√©ration des donn√©es format√©es
  const objectives = getObjectives();
  const evaluationMethods = getEvaluationMethods();
  const pedagogicalMethods = getPedagogicalMethods();
  const materialElements = getMaterialElements();
  
  // Formatage des donn√©es d'entreprise avec validations renforc√©es
  const isValidString = (value: any): boolean => {
    return value !== null && value !== undefined && value !== '' && typeof value === 'string' && value.trim().length > 0;
  };

  // Ajouter des logs avant tout traitement pour comprendre le contexte
  log(LOG_LEVELS.INFO, 'üìä [DEBUG]', 'Contexte de rendu:', { 
    viewContext, 
    pdfMode,
    hasProfessionalCompany: !!company,
    hasParticipantCompany: !!participant?.company,
    participantCompanyIsEmpty: participant?.company === '',
    participantIsIndependent: participant?.status === 'auto-entrepreneur' || participant?.status === 'freelance',
    companyHasIsIndependentFlag: company?.isIndependent === true
  });
  
  // Fonction pour garantir une valeur texte s√©curis√©e
  const safeText = (value: any, defaultValue: string = '√Ä compl√©ter'): string => {
    if (value === null || value === undefined || value === '' || (typeof value === 'string' && value.trim() === '')) {
      return defaultValue;
    }
    return String(value);
  };

  // V√©rifier les donn√©es d'entreprise avec des validations renforc√©es
  const companyName = isValidString(company?.name) ? company.name : 
                      isValidString(participant?.company) ? participant?.company : 
                      participant?.status === 'auto-entrepreneur' ? `${participant?.first_name} ${participant?.last_name} (Auto-entrepreneur)` :
                      '√Ä compl√©ter';
                      
  // Fonction pour d√©terminer si le texte de l'entreprise doit √™tre mis en √©vidence comme manquant
  const shouldHighlight = (value: string): boolean => {
    return value === '√Ä compl√©ter' || !value || value.trim() === '';
  };

  // Formater l'adresse compl√®te de l'entreprise pour "Fait en double exemplaire"
  const getFormattedCompanyAddress = (): string => {
    if (!isValidString(companyAddress)) return '';
    
    let formatted = companyAddress;
    if (company?.postal_code && company?.city) {
      formatted += `, ${company.postal_code} ${company.city}`;
    }
    if (company?.country && company.country !== 'France') {
      formatted += `, ${company.country}`;
    }
    return formatted;
  };
                      
  // D√©terminer le texte √† afficher pour l'entreprise
  const displayCompanyInfo = (): React.ReactNode => {
    if (isValidString(companyName)) {
      // Une entreprise est sp√©cifi√©e
      return (
        <>
          <p data-debug="company-name">L'entreprise : <span style={{background: 'transparent'}}>{companyName}</span></p>
          <p data-debug="company-address">Adresse de l'entreprise : <span style={{background: shouldHighlight(companyAddress) ? '#ffeeee' : 'transparent'}}>{companyAddress || '√Ä compl√©ter'}{company?.postal_code && company?.city ? `, ${company.postal_code} ${company.city}` : ''}</span></p>
          <p data-debug="company-siret">SIRET de l'entreprise : <span style={{background: shouldHighlight(companySiret) ? '#ffeeee' : 'transparent'}}>{companySiret || '√Ä compl√©ter'}</span></p>
        </>
      );
    } else if (participant?.status === 'auto-entrepreneur' || participant?.status === 'freelance') {
      // Cas sp√©cial pour auto-entrepreneur ou freelance
      return (
        <>
          <p data-debug="company-name">Apprenant ind√©pendant : <span style={{background: 'transparent'}}>{participant?.first_name} {participant?.last_name}</span></p>
          <p data-debug="company-status">Statut : <span style={{background: 'transparent'}}>{participant?.status || 'Auto-entrepreneur'}</span></p>
          <p data-debug="company-siret">SIRET : <span style={{background: shouldHighlight(companySiret) ? '#ffeeee' : 'transparent'}}>{companySiret || '√Ä compl√©ter'}</span></p>
        </>
      );
    } else {
      // Cas par d√©faut - information manquante
      return (
        <>
          <p data-debug="company-name">L'entreprise : <span style={{background: '#ffeeee'}}>√Ä compl√©ter</span></p>
          <p data-debug="company-address">Adresse de l'entreprise : <span style={{background: '#ffeeee'}}>√Ä compl√©ter</span></p>
          <p data-debug="company-siret">SIRET de l'entreprise : <span style={{background: '#ffeeee'}}>√Ä compl√©ter</span></p>
        </>
      );
    }
  };
  
  const companyAddress = safeText(company?.address);
  
  const companySiret = safeText(company?.siret);
  
  log(LOG_LEVELS.INFO, 'üìÇ [DEBUG]', 'Donn√©es format√©es d\'entreprise avec validation:', JSON.stringify({ 
    companyName,
    companyAddress,
    companySiret,
    'priorit√© name': isValidString(company?.name) ? 'company.name' : isValidString(participant?.company) ? 'participant.company' : 'valeur d√©faut',
    'priorit√© address': isValidString(company?.address) ? 'company.address' : 'valeur d√©faut',
    'priorit√© siret': isValidString(company?.siret) ? 'company.siret' : 'valeur d√©faut'
  }));
  
  // Logs d√©taill√©s sur la source des donn√©es
  log(LOG_LEVELS.INFO, 'üìÇ [DEBUG]', 'Sources des donn√©es d\'entreprise:', {
    'company objet complet': company,
    'company?.name existe': !!company?.name,
    'participant.company existe': !!participant?.company,
    'valeur participant.company': participant?.company,
    'valeur company?.name': company?.name,
    'valeur company?.address': company?.address,
    'valeur company?.siret': company?.siret
  });
  
  // V√©rifier si les valeurs sont bien d√©finies
  log(LOG_LEVELS.INFO, 'üìÇ [DEBUG]', 'V√©rification des types:', {
    'type de company': typeof company,
    'company est null': company === null,
    'company est undefined': company === undefined,
    'type de company?.name': typeof company?.name,
    'type de participant.company': typeof participant?.company,
    'JSON stringifi√©': JSON.stringify(company),
    'pdfMode activ√©': pdfMode
  });
  
  // Log pour debugger si les cases √† cocher sont correctement d√©finies
  log(LOG_LEVELS.INFO, 'üîç [DEBUG]', 'Valeurs des cases √† cocher:', JSON.stringify({
    'pedagogical_methods': training.pedagogical_methods,
    'material_elements': training.material_elements,
    'needs_evaluation': training.pedagogical_methods?.needs_evaluation,
    'theoretical_content': training.pedagogical_methods?.theoretical_content,
    'practical_exercises': training.pedagogical_methods?.practical_exercises
  }));
  
  // Log pour le debug des signatures/tampons
  log(LOG_LEVELS.INFO, 'üîé [DIAGNOSTIC_TAMPONS]', 'Props de signatures re√ßues:', JSON.stringify({
    participantSignature: participantSignature ? `${participantSignature.substring(0, 50)}...` : null,
    representativeSignature: representativeSignature ? `${representativeSignature.substring(0, 50)}...` : null,
    trainerSignature: trainerSignature ? `${trainerSignature.substring(0, 50)}...` : null,
    companySeal: companySeal ? `${companySeal.substring(0, 50)}...` : null,
    organizationSeal: organizationSeal ? `${organizationSeal.substring(0, 50)}...` : null,
  }));

  // V√©rification des tampons sp√©cifiquement
  log(LOG_LEVELS.INFO, 'üîé [DIAGNOSTIC_TAMPONS]', 'Analyse des tampons:', JSON.stringify({
    companySealProvided: !!companySeal,
    organizationSealProvided: !!organizationSeal,
    companySealType: companySeal ? typeof companySeal : 'non fourni',
    organizationSealType: organizationSeal ? typeof organizationSeal : 'non fourni',
    companySealIsURL: companySeal?.startsWith('http'),
    organizationSealIsURL: organizationSeal?.startsWith('http'),
  }));

  useEffect(() => {
    log(LOG_LEVELS.INFO, 'üîé [DIAGNOSTIC_TAMPONS]', 'Signatures et tampons apr√®s montage du composant:', {
      participantSignature: participantSignature ? 'pr√©sent' : 'absent',
      representativeSignature: representativeSignature ? 'pr√©sent' : 'absent', 
      trainerSignature: trainerSignature ? 'pr√©sent' : 'absent',
      companySeal: companySeal ? 'pr√©sent' : 'absent',
      organizationSeal: organizationSeal ? 'pr√©sent' : 'absent',
      viewContext
    });
  }, [participantSignature, representativeSignature, trainerSignature, companySeal, organizationSeal, viewContext]);

  useEffect(() => {
    // Log lors du chargement des signatures dans le composant pour identifier les substitutions
    if (signaturesInitialized) {
      log(LOG_LEVELS.INFO, 'üîé [DIAGNOSTIC_TAMPONS]', 'Signatures initialis√©es - valeurs utilis√©es:', {
        participantSig: participantSignature ? 'pr√©sent' : 'absent',
        representativeSig: representativeSignature ? 'pr√©sent' : 'absent',
        effectiveTrainerSig: effectiveTrainerSignature ? 'pr√©sent' : 'absent',
        companySealValue: companySeal ? 'pr√©sent' : 'absent',
        organizationSealValue: organizationSeal ? 'pr√©sent' : 'absent'
      });
    }
  }, [signaturesInitialized]);

  // Correction pour validateSealType
  const validateSealType = (url: string | null | undefined, expectedType: 'company' | 'organization'): boolean => {
    // Si l'URL est undefined ou null, retourner false directement
    if (!url) return false;

    // Log pour diagnostic
    log(LOG_LEVELS.INFO, 'üîç [VERIFICATION_TAMPON]', `Validation du tampon ${expectedType}: ${url}`);
    
    // V√©rifier explicitement le type de tampon
    if (expectedType === 'company') {
      // Pour les tampons d'entreprise
      return url.includes('seal_company_convention') || 
             url.includes('companySeal') ||
             url.includes('seals/company');
    } else if (expectedType === 'organization') {
      // Pour les tampons d'organisation, √™tre plus permissif
      return url.includes('seal_organization_convention') || 
             url.includes('organizationSeal') || 
             url.includes('organization_seal') ||
             url.includes('/organization-seals/') || 
             url.includes('/organization_seal_') ||
             // Ajouter des conditions qui permettent d'identifier un tampon d'organisation quel que soit le chemin
             (url.includes('signatures/') && (
               url.includes('organization') || 
               url.includes('tampon_org') || 
               url.includes('org_seal')
             ));
    }
    return false;
  };

  // Zone de signature du formateur
  const renderTrainerSignature = () => {
    // Logs d√©taill√©s pour le d√©bogage de la signature formateur
    log(LOG_LEVELS.INFO, 'üÜï [TRAINER_RENDER]', 'Rendu de la signature formateur:', {
      trainerSignature,
      safeTrainerSignature,
      representativeSignature,
      isValidTrainer: trainerSignature ? isValidTrainerSignature(trainerSignature) : false,
      viewContext,
      usesRepresentativeAsFallback: false
    });
    
    // Si nous sommes en vue √©tudiant, on utilise une approche plus permissive
    if (viewContext === 'student') {
      return (
        <div 
          className="h-28 border border-gray-300 relative" 
          id="trainer-signature-container" 
          data-signature-container="trainer" 
          data-signature-type="trainer"
        >
          {trainerSignature ? (
            <div 
              className="w-full h-full flex flex-col items-center justify-center overflow-hidden" 
              data-signature-wrapper="trainer"
              style={{ opacity: signaturesInitialized ? 1 : 0, transition: 'opacity 0.3s ease-in-out' }}
            >
              <SafeImage 
                src={getAntiCacheSignatureUrl(trainerSignature)} 
                alt="Signature du formateur" 
                className="max-h-20 max-w-[95%] object-contain"
                id="trainer-signature-img"
                data-signature="true"
                data-signature-type="trainer"
                data-signature-url={trainerSignature}
                onLoad={() => {
                  log(LOG_LEVELS.INFO, '‚úÖ [DEBUG]', 'Signature formateur charg√©e avec succ√®s:', trainerSignature);
                  markSignatureAsLoaded('trainerSig');
                }}
                onError={() => {
                  log(LOG_LEVELS.ERROR, '‚ùå [ERROR]', 'Erreur de chargement de la signature formateur:', trainerSignature);
                }}
              />
            </div>
          ) : (
            <div className="w-full h-full flex items-center justify-center bg-gray-50" data-signature-placeholder="trainer">
              <p className="text-gray-400 italic text-center">Signature en attente</p>
            </div>
          )}
        </div>
      );
    }
    
    // Cas standard (vue CRM) - CORRECTION MAJEURE: Ne JAMAIS utiliser representativeSignature comme fallback
    // pour √©viter que la signature du repr√©sentant ne s'affiche √† la place de celle du formateur
    return (
      <div 
        className="h-28 border border-gray-300 relative" 
        id="trainer-signature-container" 
        data-signature-container="trainer" 
        data-signature-type="trainer"
      >
        {/* N'utiliser que safeTrainerSignature, jamais representativeSignature */}
        {safeTrainerSignature && typeof safeTrainerSignature === 'string' && isValidTrainerSignature(safeTrainerSignature) ? (
          <div 
            className="w-full h-full flex flex-col items-center justify-center overflow-hidden" 
            data-signature-wrapper="trainer"
            style={{ opacity: signaturesInitialized ? 1 : 0, transition: 'opacity 0.3s ease-in-out' }}
          >
            <SafeImage 
              src={getAntiCacheSignatureUrl(safeTrainerSignature)} 
              alt="Signature du formateur" 
              className="max-h-20 max-w-[95%] object-contain"
              id="trainer-signature-img"
              data-signature="true"
              data-signature-type="trainer"
              data-signature-url={safeTrainerSignature}
              onLoad={() => {
                log(LOG_LEVELS.INFO, '‚úÖ [DEBUG]', 'Signature formateur charg√©e avec succ√®s:', safeTrainerSignature);
                markSignatureAsLoaded('trainerSig');
              }}
              onError={() => {
                log(LOG_LEVELS.ERROR, '‚ùå [ERROR]', 'Erreur de chargement de la signature formateur:', safeTrainerSignature);
              }}
            />
          </div>
        ) : (
          <div className="w-full h-full flex items-center justify-center bg-gray-50" data-signature-placeholder="trainer">
            <p className="text-gray-400 italic text-center">Signature en attente</p>
          </div>
        )}
      </div>
    );
  };
  
  // Zone de tampon organisme
  const renderOrganizationSeal = () => {
    // Pr√©paration de l'URL valid√©e du tampon - s'assurer que organizationSeal n'est pas undefined
    const validatedSeal = validateSealURL(organizationSeal || null);
    
    // Validation du type de tampon
    const sealIsValid = validateSealType(validatedSeal, 'organization');
    
    // Si le tampon est d√©j√† charg√©, utiliser la version en cache
    const isAlreadyLoaded = loadedSignatures.organizationSeal && sealURLCache.organizationSeal;
    
    log(LOG_LEVELS.INFO, 'üÜï [SEAL_RENDER]', 'Rendu du tampon organisme:', {
      organizationSeal,
      validated: sealIsValid,
      viewContext,
      isInCache: isAlreadyLoaded
    });
    
    // D√©terminer l'URL finale √† utiliser
    const finalSealURL = isAlreadyLoaded 
      ? sealURLCache.organizationSeal 
      : (validatedSeal && sealIsValid ? getAntiCacheSignatureUrl(validatedSeal, true) : null);
    
    return (
      <div 
        className="h-28 border border-gray-300 relative" 
        id="organization-seal-container" 
        data-signature-container="organizationSeal" 
        data-signature-type="organizationSeal"
      >
        {finalSealURL ? (
          <div 
            className="w-full h-full flex items-center justify-center overflow-hidden" 
            data-signature-wrapper="organizationSeal"
            style={{ opacity: signaturesInitialized ? 1 : 0, transition: 'opacity 0.3s ease-in-out' }}
          >
            <SafeImage 
              src={finalSealURL} 
              alt="Tampon de l'organisme" 
              className="max-h-24 max-w-[95%] object-contain"
              id="organization-seal-img"
              data-signature="true"
              data-signature-type="organizationSeal"
              data-signature-url={finalSealURL}
              onLoad={() => {
                log(LOG_LEVELS.INFO, '‚úÖ [DEBUG]', 'Tampon organisme charg√© avec succ√®s:', finalSealURL);
                // Enregistrer l'URL qui a bien fonctionn√© dans le cache
                if (!sealURLCache.organizationSeal) {
                  setSealURLCache(prev => ({
                    ...prev,
                    organizationSeal: finalSealURL
                  }));
                  log(LOG_LEVELS.INFO, 'üíæ [CACHE]', 'URL du tampon organisme mise en cache:', finalSealURL);
                }
                markSignatureAsLoaded('organizationSeal');
              }}
              onError={() => {
                log(LOG_LEVELS.ERROR, '‚ùå [ERROR]', 'Erreur de chargement du tampon organisme:', finalSealURL);
              }}
            />
          </div>
        ) : (
          <div className="w-full h-full flex items-center justify-center bg-gray-50" data-signature-placeholder="organizationSeal">
            <p className="text-gray-400 italic text-center">Tampon en attente</p>
          </div>
        )}
      </div>
    );
  };

  // Zone de signature du repr√©sentant ou de l'apprenant
  const renderParticipantSignature = () => {
    // Variables pour la clart√©
    const hasParticipantSignature = participantSignature && typeof participantSignature === 'string' && isSignatureURL(participantSignature);
    const hasRepresentativeSignature = representativeSignature && typeof representativeSignature === 'string' && isSignatureURL(representativeSignature);
    
    // URL effective √† afficher (repr√©sentant en priorit√© si pr√©sent)
    const effectiveSignature = hasRepresentativeSignature ? representativeSignature : (hasParticipantSignature ? participantSignature : null);
    
    // Si la signature est d√©j√† charg√©e, ne pas reg√©n√©rer le composant
    const isSignatureLoaded = hasRepresentativeSignature ? loadedSignatures.representativeSig : loadedSignatures.participantSig;
    
    // Type de signature (pour le texte affich√©)
    const signatureType = hasRepresentativeSignature ? "representative" : "participant";
    const signatureLabel = hasRepresentativeSignature ? "Signature du dirigeant" : "Signature de l'apprenant";
    
    return (
      <div 
        className="h-28 border border-gray-300 relative" 
        id="participant-signature-container" 
        data-signature-container={signatureType} 
        data-signature-type={signatureType}
      >
        {effectiveSignature ? (
          <div 
            className="w-full h-full flex flex-col items-center justify-center overflow-hidden" 
            data-signature-wrapper={signatureType}
            style={{ opacity: signaturesInitialized ? 1 : 0, transition: 'opacity 0.3s ease-in-out' }}
          >
            <SafeImage 
              src={getAntiCacheSignatureUrl(effectiveSignature)} 
              alt={signatureLabel} 
              className="max-h-20 max-w-[95%] object-contain"
              id={`${signatureType}-signature-img`}
              data-signature="true"
              data-signature-type={signatureType}
              data-signature-url={effectiveSignature}
              onLoad={() => {
                log(LOG_LEVELS.INFO, '‚úÖ [DEBUG]', `${signatureLabel} charg√©e avec succ√®s`, effectiveSignature);
                if (hasRepresentativeSignature) {
                  markSignatureAsLoaded('representativeSig');
                } else {
                  markSignatureAsLoaded('participantSig');
                }
              }}
              onError={() => {
                log(LOG_LEVELS.ERROR, '‚ùå [ERROR]', `Erreur de chargement de la ${signatureLabel.toLowerCase()}:`, effectiveSignature);
              }}
            />
          </div>
        ) : (
          <div className="w-full h-full flex items-center justify-center bg-gray-50" data-signature-placeholder={signatureType}>
            <p className="text-gray-400 italic text-center">Signature en attente</p>
          </div>
        )}
      </div>
    );
  };

  // Zone de tampon de l'entreprise
  const renderCompanySeal = () => {
    // Pr√©paration de l'URL valid√©e du tampon - s'assurer que companySeal n'est pas undefined
    const validatedSeal = validateSealURL(companySeal || null);
    
    // Validation du type de tampon
    const sealIsValid = validateSealType(validatedSeal, 'company');
    
    // S'assurer que le tampon n'est pas une signature en v√©rifiant son nom
    const isTrulySeal = validatedSeal ? 
      (validatedSeal.includes('seal') || validatedSeal.includes('stamp') || validatedSeal.includes('tampon')) : 
      false;
    
    // Si le tampon est d√©j√† charg√©, utiliser la version en cache
    const isAlreadyLoaded = loadedSignatures.companySeal && sealURLCache.companySeal;
    
    log(LOG_LEVELS.INFO, 'üîç [COMPANY_SEAL]', 'V√©rification du tampon entreprise:', {
      validatedSeal: validatedSeal ? 'URL valide' : 'Pas d\'URL',
      sealIsValid,
      isTrulySeal,
      isInCache: loadedSignatures.companySeal,
      hasCachedURL: !!sealURLCache.companySeal
    });
    
    // D√©terminer l'URL finale √† utiliser
    const finalSealURL = isAlreadyLoaded 
      ? sealURLCache.companySeal 
      : (validatedSeal && sealIsValid ? getAntiCacheSignatureUrl(validatedSeal, true) : null);
    
    return (
      <div 
        className="h-28 border border-gray-300 relative" 
        id="company-seal-container" 
        data-seal-container="company" 
        data-seal-type="company"
      >
        {finalSealURL ? (
          <div 
            className="w-full h-full flex items-center justify-center overflow-hidden" 
            data-seal-wrapper="company"
            style={{ opacity: signaturesInitialized ? 1 : 0, transition: 'opacity 0.3s ease-in-out' }}
          >
            <SafeImage 
              src={finalSealURL} 
              alt="Tampon de l'entreprise" 
              className="max-h-24 max-w-[95%] object-contain"
              id="company-seal-img"
              data-seal="true"
              data-seal-type="company"
              data-seal-url={finalSealURL}
              onLoad={() => {
                log(LOG_LEVELS.INFO, '‚úÖ [DEBUG]', 'Tampon entreprise charg√© avec succ√®s:', finalSealURL);
                // Enregistrer l'URL qui a bien fonctionn√© dans le cache
                if (!sealURLCache.companySeal) {
                  setSealURLCache(prev => ({
                    ...prev,
                    companySeal: finalSealURL
                  }));
                  log(LOG_LEVELS.INFO, 'üíæ [CACHE]', 'URL du tampon entreprise mise en cache:', finalSealURL);
                }
                markSignatureAsLoaded('companySeal');
              }}
              onError={() => {
                log(LOG_LEVELS.ERROR, '‚ùå [ERROR]', 'Erreur de chargement du tampon entreprise:', finalSealURL);
              }}
            />
          </div>
        ) : (
          <div className="w-full h-full flex items-center justify-center bg-gray-50" data-seal-placeholder="company">
            <p className="text-gray-400 italic text-center">Tampon en attente</p>
          </div>
        )}
      </div>
    );
  };

  // Effet pour √©viter les rechargements multiples des signatures
  useEffect(() => {
    // Ne d√©clencher qu'une seule fois apr√®s le montage initial
    if (signaturesInitialized) {
      log(LOG_LEVELS.INFO, 'üîí [SIGNATURES]', 'Les signatures sont d√©j√† initialis√©es, pas de rechargement');
      return;
    }

    // Initialiser les signatures apr√®s un court d√©lai
    const timer = setTimeout(() => {
      log(LOG_LEVELS.INFO, 'üîÑ [SIGNATURES]', 'Initialisation des signatures et tampons');
      setSignaturesInitialized(true);
    }, 200);

    return () => clearTimeout(timer);
  }, []);

  // Effet pour √©viter les rechargements de signatures d√©j√† charg√©es
  useEffect(() => {
    // Journaliser l'√©tat actuel des signatures charg√©es
    log(LOG_LEVELS.INFO, 'üîç [SIGNATURES]', '√âtat actuel des signatures charg√©es:', loadedSignatures);
    
    // V√©rifier si toutes les signatures disponibles sont charg√©es
    const allSignaturesLoaded = (
      (!participantSignature || loadedSignatures.participantSig) &&
      (!representativeSignature || loadedSignatures.representativeSig) &&
      (!trainerSignature || loadedSignatures.trainerSig) &&
      (!companySeal || loadedSignatures.companySeal) &&
      (!organizationSeal || loadedSignatures.organizationSeal)
    );
    
    if (allSignaturesLoaded && signaturesInitialized) {
      log(LOG_LEVELS.INFO, '‚úÖ [SIGNATURES]', 'Toutes les signatures disponibles sont charg√©es');
    }
  }, [loadedSignatures, participantSignature, representativeSignature, trainerSignature, companySeal, organizationSeal]);

  // Fonction pour formater l'adresse de l'organisme de formation
  const formatOrganizationAddress = (settings: OrganizationSettings): string => {
    const parts = [settings.address];
    
    if (settings.postal_code || settings.city) {
      const locationParts = [settings.postal_code, settings.city].filter(Boolean);
      parts.push(locationParts.join(' '));
    }
    
    if (settings.country && settings.country.toLowerCase() !== 'france') {
      parts.push(settings.country);
    }
    
    return parts.filter(Boolean).join(', ');
  };

  // Fonction pour obtenir les informations de l'organisme de formation
  const getOrganizationInfo = (settings: OrganizationSettings) => {
    return {
      name: settings.organization_name,
      address: formatOrganizationAddress(settings),
      siret: settings.siret || 'SIRET non renseign√©',
      activityNumber: settings.activity_declaration_number || 'Num√©ro de d√©claration d\'activit√© non renseign√©',
      representative: settings.representative_name ? 
        `${settings.representative_name}${settings.representative_title ? `, ${settings.representative_title}` : ''}` :
        'Repr√©sentant non renseign√©'
    };
  };

  return (
    <div ref={documentRef} className="bg-white p-8 shadow-sm border border-gray-200 mx-auto" 
      style={{ maxWidth: '800px' }}
         data-debug={`template-${pdfMode ? 'pdf' : 'normal'}-${viewContext}`}>
      <div className="text-center mb-8">
        <h1 className="text-2xl font-bold mb-2">CONVENTION DE FORMATION PROFESSIONNELLE</h1>
        <p className="text-sm text-gray-600">(Articles L.6353-1 du Code du travail)</p>
      </div>
      
      <div className="mb-6">
        <p><strong>Entre</strong></p>
        <p>L'organisme de formation : {organizationSettings.organization_name}</p>
        <p>Num√©ro de d√©claration d'activit√© de l'organisme de formation : {organizationSettings.activity_declaration_number}</p>
        <p>Num√©ro SIRET de l'organisme de formation : {organizationSettings.siret}</p>
        <p>Adresse de l'organisme de formation : {organizationSettings.address}
          {organizationSettings.postal_code && organizationSettings.city 
            ? `, ${organizationSettings.postal_code} ${organizationSettings.city}` 
            : ''}
          {organizationSettings.country && organizationSettings.country !== 'France'
            ? `, ${organizationSettings.country}`
            : ''}
        </p>
      </div>
      
      <div className="mb-6">
        <p><strong>Et</strong></p>
        {displayCompanyInfo()}
        {/* Test visible si les donn√©es manquent */}
        {(companyName === '√Ä compl√©ter' || !companyName || companyAddress === '√Ä compl√©ter' || !companyAddress || companySiret === '√Ä compl√©ter' || !companySiret) && (
          <div style={{
            background: '#ffcccc', 
            padding: '5px', 
            marginTop: '5px', 
            border: '1px solid red', 
            borderRadius: '3px',
            fontSize: '12px'
          }}>
            Attention : Certaines donn√©es d'entreprise sont manquantes. Contexte : {viewContext}, Mode PDF: {pdfMode ? 'Oui' : 'Non'}
          </div>
        )}
      </div>
      
      <div className="mb-6">
        <p>Pour le(s) b√©n√©ficiaire(s) : (ci-apr√®s d√©nomm√©(s) le(s) stagiaire(s))</p>
        <table className="w-full border mt-2">
          <tbody>
            <tr>
              <th className="border p-2 text-center">Stagiaire</th>
              <th className="border p-2 text-center">Fonction</th>
            </tr>
            {allParticipants.map((participant, index) => (
              <tr key={participant.id || index}>
                <td className="border p-2 text-center">{participant.first_name} {participant.last_name}</td>
                <td className="border p-2 text-center">{participant.job_position || '√Ä compl√©ter'}</td>
              </tr>
            ))}
            {allParticipants.length === 0 && (
              <tr>
                <td colSpan={2} className="border p-2 text-center text-gray-500">Aucun stagiaire n'est inscrit √† cette formation</td>
            </tr>
            )}
          </tbody>
        </table>
      </div>
      
      <div className="mt-4">
        <h2 className="font-bold text-red-600 border-b border-red-600 pb-1 mb-4">I ‚Äì OBJET</h2>
        <p>L'action de formation entre dans la cat√©gorie : ¬´ Les actions de formation ¬ª pr√©vue √† l'article L.6313-1 du Code du travail.</p>
        <p className="mt-2">En ex√©cution de la pr√©sente convention, l'organisme de formation s'engage √† organiser l'action de formation professionnelle intitul√©e : {training.title}</p>
      </div>
      
      <div className="mt-4">
        <h2 className="font-bold text-red-600 border-b border-red-600 pb-1 mb-4">II ‚Äì NATURE ET CARACTERISTIQUES DE L'ACTION DE FORMATION</h2>
        <p>Permettre au stagiaire de :</p>
        <ul className="list-disc pl-8 mt-2">
          {objectives.map((objective, index) => (
            <li key={index} className="mb-1">{objective}</li>
          ))}
        </ul>
        
        <p className="mt-4">La dur√©e de la formation est fix√©e √† {training.duration}</p>
        <p className="mt-1">Horaires de Stage : de 9h00 √† 12h30 et de 13h30 √† 17h00</p>
        
        <p className="mt-4">Le programme d√©taill√© de l'action de formation figure en annexe de la pr√©sente convention.</p>
      </div>
      
      <div className="mt-4">
        <h2 className="font-bold text-red-600 border-b border-red-600 pb-1 mb-4">III ‚Äì NIVEAU DE CONNAISSANCES PREALABLES N√âCESSAIRE</h2>
        <p>Aucun pr√©requis n'est n√©cessaire.</p>
      </div>
      
      <div className="mt-4">
        <h2 className="font-bold text-red-600 border-b border-red-600 pb-1 mb-4">IV ‚Äì ORGANISATION DE L'ACTION DE FORMATION</h2>
        <p>L'action de formation aura lieu (dates ou p√©riode) : {getTrainingDates()}</p>
        <p>Lieu de formation : {training.location}</p>
        
        <p className="mt-4 italic">Dans le cas o√π la formation a lieu au sein de l'entreprise b√©n√©ficiaire, l'entreprise s'engage √† assurer la s√©curit√© des participants. L'environnement de la formation doit se d√©rouler dans des conditions techniques et sanitaires appropri√©es.</p>
        
        <p className="mt-4">Les conditions g√©n√©rales dans lesquelles la formation est dispens√©e, notamment les moyens p√©dagogiques et techniques, sont les suivantes :</p>
        <ul className="list-disc pl-8 mt-2">
          {training.pedagogical_methods?.needs_evaluation && <li>√âvaluation des besoins et du profil du participant</li>}
          {training.pedagogical_methods?.theoretical_content && <li>Apport th√©orique et m√©thodologique</li>}
          {training.pedagogical_methods?.practical_exercises && <li>Questionnaires et exercices pratiques</li>}
          {training.pedagogical_methods?.case_studies && <li>√âtudes de cas</li>}
          {training.pedagogical_methods?.experience_sharing && <li>Retours d'exp√©riences</li>}
          {training.pedagogical_methods?.digital_support && <li>Support de cours num√©rique</li>}
          {(!training.pedagogical_methods || 
           (!training.pedagogical_methods.needs_evaluation && 
           !training.pedagogical_methods.theoretical_content && 
           !training.pedagogical_methods.practical_exercises && 
           !training.pedagogical_methods.case_studies && 
           !training.pedagogical_methods.experience_sharing && 
           !training.pedagogical_methods.digital_support)) && 
            <li>√Ä compl√©ter</li>
          }
        </ul>
        
        <p className="mt-4">√âl√©ments mat√©riels :</p>
        <ul className="list-disc pl-8 mt-2">
          {training.material_elements?.computer_provided && <li>Mise √† disposition du mat√©riel informatique</li>}
          {training.material_elements?.pedagogical_material && <li>Mise √† disposition du mat√©riel p√©dagogique</li>}
          {training.material_elements?.digital_support_provided && <li>Support de cours au format num√©rique</li>}
          {(!training.material_elements ||
           (!training.material_elements.computer_provided && 
           !training.material_elements.pedagogical_material && 
           !training.material_elements.digital_support_provided)) && 
            <li>√Ä compl√©ter</li>
          }
        </ul>
        
        <p className="mt-2">Les conditions d√©taill√©es figurent en annexe de la pr√©sente convention.</p>
      </div>
      
      <div className="mt-4">
        <h2 className="font-bold text-red-600 border-b border-red-600 pb-1 mb-4">V ‚Äì MOYENS PERMETTANT D'APPRECIER LES RESULTATS DE L'ACTION</h2>
        <ul className="list-disc pl-8 mt-2">
          {training.evaluation_methods?.profile_evaluation && <li>Evaluation individuelle du profil, des attentes et des besoins</li>}
          {training.evaluation_methods?.skills_evaluation && <li>Evaluation des comp√©tences en d√©but et fin de formation</li>}
          {training.evaluation_methods?.knowledge_evaluation && <li>√âvaluation des connaissances √† chaque √©tape</li>}
          {training.evaluation_methods?.satisfaction_survey && <li>Questionnaire d'√©valuation de la satisfaction</li>}
          {(!training.evaluation_methods ||
           (!training.evaluation_methods.profile_evaluation && 
           !training.evaluation_methods.skills_evaluation && 
           !training.evaluation_methods.knowledge_evaluation && 
           !training.evaluation_methods.satisfaction_survey)) && 
           <li>√Ä compl√©ter</li>
          }
        </ul>
      </div>
      
      <div className="mt-4">
        <h2 className="font-bold text-red-600 border-b border-red-600 pb-1 mb-4">VI ‚Äì SANCTION DE LA FORMATION</h2>
        <p>En application de l'article L.6353-1 du Code du travail, une attestation mentionnant les objectifs, la nature et la dur√©e de l'action et les r√©sultats de l'√©valuation des acquis de la formation sera remise au stagiaire √† l'issue de la formation.</p>
      </div>
      
      <div className="mt-4">
        <h2 className="font-bold text-red-600 border-b border-red-600 pb-1 mb-4">VII ‚Äì MOYENS PERMETTANT DE SUIVRE L'EXECUTION DE L'ACTION</h2>
        <ul className="list-disc pl-8 mt-2">
          {training.tracking_methods?.attendance_sheet && <li>Feuille d'√©margement</li>}
          {training.tracking_methods?.completion_certificate && <li>Attestation de fin de formation</li>}
          {(!training.tracking_methods ||
            (!training.tracking_methods.attendance_sheet && !training.tracking_methods.completion_certificate)) && 
            <li>√Ä compl√©ter</li>
          }
        </ul>
      </div>
      
      <div className="mt-4">
        <h2 className="font-bold text-red-600 border-b border-red-600 pb-1 mb-4">VIII ‚Äì NON-R√âALISATION DE LA PRESTATION DE FORMATION</h2>
        <p>En application de l'article L. 6354-1 du Code du travail, il est convenu entre les signataires de la pr√©sente convention, que faute de r√©alisation totale ou partielle de la prestation de formation, l'organisme prestataire doit rembourser au cocontractant les sommes ind√ªment per√ßues de ce fait.</p>
      </div>
      
      <div className="mt-4">
        <h2 className="font-bold text-red-600 border-b border-red-600 pb-1 mb-4">IX ‚Äì DISPOSITIONS FINANCIERES</h2>
        <p>Le prix de l'action de formation est fix√© √† : {formatPrice(training.price)} {training.price ? 'HT + TVA (20%) : ' + (training.price * 0.2).toFixed(2) + '‚Ç¨ = ' + (training.price * 1.2).toFixed(2) + '‚Ç¨ TTC' : ''}</p>
      </div>
      
      <div className="mt-4">
        <h2 className="font-bold text-red-600 border-b border-red-600 pb-1 mb-4">X ‚Äì INTERRUPTION DU STAGE</h2>
        <p>En cas de cessation anticip√©e de la formation du fait de l'organisme de formation ou en cas de renoncement par le b√©n√©ficiaire pour un autre motif que la force majeure d√ªment reconnue, le pr√©sent contrat est r√©sili√©. Dans ce cas, seules les prestations effectivement dispens√©es sont dues au prorata temporis de leur valeur pr√©vue au pr√©sent contrat.</p>
        <p className="mt-2">Si le stagiaire est emp√™ch√© de suivre la formation par suite de force majeure d√ªment reconnue, la convention de formation professionnelle est r√©sili√©e. Dans ce cas, seules les prestations effectivement dispens√©es sont dues au prorata temporis de leur valeur pr√©vue au pr√©sent contrat.</p>
      </div>
      
      <div className="mt-4">
        <h2 className="font-bold text-red-600 border-b border-red-600 pb-1 mb-4">XI ‚Äì CAS DE DIFFEREND</h2>
        <p className="mb-6">Si une contestation ou un diff√©rend n'ont pu √™tre r√©gl√©s √† l'amiable, seul le tribunal de commerce dans le ressort de la juridiction du si√®ge social du centre de formation sera comp√©tent pour r√©gler le litige.</p>
      </div>
      
      {/* Section de l'organisme de formation */}
      
      <div className="mt-8 flex justify-between">
        <div className="w-1/2 pr-4">
          <p><strong>Pour l'entreprise</strong></p>
          <p>Le dirigeant</p>
          <p>(Signature et cachet)</p>
          
          <div className="mt-2 flex flex-col space-y-2">
            {/* Zone de signature du repr√©sentant */}
            {renderParticipantSignature()}
            
            {/* Zone de tampon entreprise */}
            {renderCompanySeal()}
          </div>
        </div>
        <div className="w-1/2">
          <p><strong>Pour l'organisme de formation</strong></p>
          <p>(Signature et cachet)</p>
          
          <div className="mt-2 flex flex-col space-y-2">
            {/* 
              Affichage de la signature du formateur seulement pour l'organisme,
              en √©vitant d'utiliser la signature du repr√©sentant
            */}
            {renderTrainerSignature()}
            
            {/* Zone de tampon organisme */}
            {renderOrganizationSeal()}
          </div>
        </div>
      </div>
      
      <div className="mt-8">
        <p>Fait en double exemplaire, √† {organizationSettings.city || '_______________'}{getFormattedCompanyAddress() ? ` et √† ${getFormattedCompanyAddress()}` : ''}, le {new Date().toLocaleDateString('fr-FR')}</p>
        {/* ... reste du code des signatures ... */}
      </div>
    </div>
  );
};

export default UnifiedTrainingAgreementTemplate; 