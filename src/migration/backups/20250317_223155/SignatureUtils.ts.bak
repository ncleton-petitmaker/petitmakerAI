/**
 * Module d'utilitaires pour la gestion des signatures dans les documents
 * 
 * Ce module fournit des fonctions pour:
 * - Nettoyer les sections de signature ind√©sirables
 * - Configurer les conteneurs de signature
 * - Pr√©charger les images de signature
 * - V√©rifier la validit√© des URLs de signature
 */

import { supabase } from '../lib/supabase';

// Types de signature standardis√©s
export type SignatureType = 'participant' | 'stagiaire' | 'company' | 'trainer' | 'representative';

/**
 * V√©rifie si l'URL fournie est une URL d'image valide
 */
export const isValidImageUrl = (url: string | null): boolean => {
  if (!url) return false;
  
  try {
    const parsedUrl = new URL(url);
    const path = parsedUrl.pathname.toLowerCase();
    return path.endsWith('.png') || path.endsWith('.jpg') || path.endsWith('.jpeg') || path.endsWith('.gif') || path.endsWith('.webp');
  } catch (e) {
    return false;
  }
};

/**
 * Ajoute un anti-cache √† une URL d'image pour forcer son rechargement
 * Version am√©lior√©e avec nettoyage pr√©alable de l'URL et support de plusieurs strat√©gies
 */
export const addCacheBuster = (url: string | null, strategy: 'timestamp' | 'random' | 'both' = 'both'): string => {
  if (!url) return '';
  
  try {
    // Nettoyer l'URL pour enlever tout param√®tre existant
    const baseUrl = url.split('?')[0];
    
    // Ajouter les param√®tres anti-cache selon la strat√©gie choisie
    if (strategy === 'timestamp' || strategy === 'both') {
      return `${baseUrl}?t=${Date.now()}`;
    } else if (strategy === 'random') {
      return `${baseUrl}?r=${Math.random().toString(36).substring(2, 15)}`;
    } else {
      // Par d√©faut, utiliser les deux
      return `${baseUrl}?t=${Date.now()}&r=${Math.random().toString(36).substring(2, 15)}`;
    }
  } catch (e) {
    // En cas d'erreur, retourner l'URL originale
    console.error('Erreur lors de l\'ajout d\'anti-cache:', e);
    return url;
  }
};

/**
 * V√©rifie qu'un fichier de signature existe et est accessible
 * Cette fonction effectue plusieurs tentatives avec diff√©rentes m√©thodes
 */
export const verifySignatureFile = async (url: string | null): Promise<{
  exists: boolean;
  url: string | null;
  status?: number;
  statusText?: string;
  message?: string;
}> => {
  if (!url) {
    return { exists: false, url: null, message: 'URL non fournie' };
  }
  
  try {
    console.log('üîç [SIGNATURE] V√©rification de l\'existence du fichier:', url);
    
    // Nettoyer l'URL (enlever les param√®tres anti-cache existants)
    const cleanUrl = url.split('?')[0];
    
    // Premi√®re approche: requ√™te HTTP directe
    try {
      const response = await fetch(cleanUrl, {
        method: 'HEAD',
        cache: 'no-store',
        headers: {
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache'
        }
      });
      
      console.log('üîç [SIGNATURE] R√©sultat de la v√©rification HTTP:', {
        status: response.status,
        statusText: response.statusText,
        ok: response.ok,
        headers: Object.fromEntries([...response.headers])
      });
      
      // Si le fichier existe
      if (response.ok) {
        return {
          exists: true,
          url: cleanUrl,
          status: response.status,
          statusText: response.statusText,
          message: 'Fichier accessible via HTTP'
        };
      }
      
      // Si le fichier n'existe pas
      if (response.status === 404) {
        return {
          exists: false,
          url: cleanUrl,
          status: response.status,
          statusText: response.statusText,
          message: 'Fichier non trouv√© (HTTP 404)'
        };
      }
    } catch (fetchError) {
      console.error('üîç [SIGNATURE] Erreur lors de la v√©rification HTTP:', fetchError);
    }
    
    // Deuxi√®me approche: API Supabase pour v√©rifier dans le bucket
    try {
      // Extraire le nom du fichier de l'URL
      const urlObj = new URL(cleanUrl);
      const pathParts = urlObj.pathname.split('/');
      const filename = pathParts[pathParts.length - 1];
      
      if (!filename) {
        return {
          exists: false, 
          url: cleanUrl,
          message: 'Impossible d\'extraire le nom du fichier de l\'URL'
        };
      }
      
      // V√©rifier si le fichier existe via Supabase Storage API
      const { data, error } = await supabase.storage
        .from('signatures')
        .list('', { 
          limit: 100,
          sortBy: { column: 'name', order: 'desc' }
        });
      
      if (error) {
        console.error('üîç [SIGNATURE] Erreur lors de la liste des fichiers:', error);
        return {
          exists: false,
          url: cleanUrl,
          message: `Erreur Supabase: ${error.message}`
        };
      }
      
      const fileExists = data.some(f => f.name === filename);
      if (fileExists) {
        return {
          exists: true,
          url: cleanUrl,
          message: 'Fichier trouv√© dans le bucket Supabase'
        };
      }
    } catch (supabaseError) {
      console.error('üîç [SIGNATURE] Erreur lors de la v√©rification Supabase:', supabaseError);
    }
    
    // Par d√©faut, pr√©sumer que le fichier n'existe pas
    return {
      exists: false,
      url: cleanUrl,
      message: 'Fichier non trouv√© apr√®s plusieurs tentatives'
    };
  } catch (error) {
    console.error('üîç [SIGNATURE] Exception lors de la v√©rification du fichier:', error);
    return {
      exists: false,
      url: url,
      message: `Exception: ${error instanceof Error ? error.message : 'Erreur inconnue'}`
    };
  }
};

/**
 * V√©rifie si une URL est une URL Supabase pointant vers un fichier de signature
 * @param url L'URL √† v√©rifier
 * @returns Vrai si c'est une URL Supabase de signature
 */
export const isSupabaseSignatureUrl = (url: string | null | undefined): boolean => {
  if (!url) return false;
  return url.includes('supabase.co/storage/v1/object/public/signatures/');
};

/**
 * Cr√©e une URL de fallback pour une signature
 * Utilis√© quand l'URL de signature originale ne peut pas √™tre charg√©e
 * 
 * @param type Le type de signature (participant, representative, trainer)
 * @returns Une URL vers une image g√©n√©rique de signature
 */
export const createSignatureFallbackUrl = (type: 'participant' | 'representative' | 'trainer'): string => {
  // Utilise des images statiques h√©berg√©es dans le dossier public
  return `/images/signatures/${type}_signature_placeholder.png`;
};

/**
 * Charge une image avec un m√©canisme de retry
 * @param url L'URL de l'image √† charger
 * @param retries Nombre de tentatives (d√©faut: 3)
 * @param delay D√©lai initial entre les tentatives en ms (d√©faut: 1000)
 * @returns Une promesse qui se r√©sout avec une r√©ponse fetch si l'image est charg√©e
 */
export const loadImageWithRetry = async (
  url: string, 
  retries = 3, 
  delay = 1000
): Promise<Response> => {
  let lastError: Error | null = null;
  
  // Normaliser l'URL si c'est une URL Supabase
  let normalizedUrl = url;
  if (isSupabaseSignatureUrl(url)) {
    normalizedUrl = normalizeSupabaseUrl(url) || url;
  }
  
  // Ajouter un cache buster √† l'URL
  const cacheBustedUrl = addCacheBuster(normalizedUrl);
  console.log(`üîç [DEBUG] Tentative de chargement d'image avec retry: ${cacheBustedUrl}`);
  
  for (let i = 0; i < retries; i++) {
    try {
      // Utilisation de fetch avec mode no-cors pour √©viter les erreurs CORS
      const response = await fetch(cacheBustedUrl, { 
        method: 'GET',
        mode: 'no-cors',
        cache: 'no-cache',
        headers: {
          'Cache-Control': 'no-cache, no-store, must-revalidate',
          'Pragma': 'no-cache',
          'Expires': '0'
        }
      });
      
      console.log(`üîç [DEBUG] Tentative ${i + 1}/${retries} - Statut: ${response.status}`);
      
      if (response.ok || response.type === 'opaque') {
        console.log(`üîç [DEBUG] Image charg√©e avec succ√®s (tentative ${i + 1})`);
        return response;
      }
    } catch (error) {
      lastError = error as Error;
      console.error(`üîç [DEBUG] Erreur lors de la tentative ${i + 1}/${retries}:`, error);
    }
    
    // Attendre un d√©lai progressif avant de r√©essayer (d√©lai exponentiel)
    const waitTime = delay * Math.pow(2, i);
    console.log(`üîç [DEBUG] Attente de ${waitTime}ms avant nouvelle tentative...`);
    await new Promise(resolve => setTimeout(resolve, waitTime));
  }
  
  // Si on arrive ici, toutes les tentatives ont √©chou√©
  throw lastError || new Error(`Impossible de charger l'image apr√®s ${retries} tentatives`);
};

/**
 * Pr√©charge plusieurs images en parall√®le
 * @param urls Liste des URLs √† pr√©charger
 * @returns Promise qui se r√©sout quand toutes les images sont charg√©es ou ont √©chou√©
 */
export const preloadImages = async (urls: (string | null | undefined)[]): Promise<Map<string, boolean>> => {
  const results = new Map<string, boolean>();
  const filteredUrls = urls.filter((url): url is string => !!url);
  
  if (filteredUrls.length === 0) return results;
  
  console.log(`üîç [DEBUG] Pr√©chargement de ${filteredUrls.length} images...`);
  
  await Promise.allSettled(
    filteredUrls.map(async (url) => {
      try {
        if (isSupabaseSignatureUrl(url)) {
          // Pour les URLs Supabase, utiliser le m√©canisme de retry
          await loadImageWithRetry(url);
          results.set(url, true);
        } else {
          // Pour les autres URLs, utiliser la m√©thode standard
          await new Promise<void>((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
              results.set(url, true);
              resolve();
            };
            img.onerror = () => {
              results.set(url, false);
              reject(new Error(`√âchec du chargement de ${url}`));
            };
            img.src = addCacheBuster(url);
          });
        }
      } catch (error) {
        console.error(`üîç [DEBUG] Erreur lors du pr√©chargement de ${url}:`, error);
        results.set(url, false);
      }
    })
  );
  
  const successCount = Array.from(results.values()).filter(Boolean).length;
  console.log(`üîç [DEBUG] Pr√©chargement termin√©: ${successCount}/${filteredUrls.length} images charg√©es avec succ√®s`);
  
  return results;
};

/**
 * Normalise une URL Supabase pour √©viter les erreurs 400 (version synchrone)
 * Cette fonction est particuli√®rement utile pour les URLs de signatures qui peuvent
 * avoir une structure complexe de dossiers qui cause des probl√®mes.
 * 
 * @param url L'URL Supabase √† normaliser
 * @returns L'URL normalis√©e
 */
export const normalizeSupabaseUrl = (url: string | null | undefined): string | null | undefined => {
  if (!url) return url;
  
  // Si ce n'est pas une URL Supabase pour les signatures, retourner telle quelle
  if (!isSupabaseSignatureUrl(url)) return url;
  
  try {
    console.log('üî• [DEBUG] Normalisation d\'URL Supabase (sync):', url);
    
    // Analyse et extraction des composants d'URL
    const urlObj = new URL(url);
    const host = urlObj.origin;
    const pathname = urlObj.pathname;
    
    console.log('üî• [DEBUG] D√©composition de l\'URL:');
    console.log('üî• [DEBUG] - H√¥te:', host);
    console.log('üî• [DEBUG] - Chemin complet:', pathname);
    
    // Examiner la structure du chemin
    const pathParts = pathname.split('/');
    console.log('üî• [DEBUG] - Parties du chemin:', pathParts);
    
    // Extraire uniquement le nom du fichier (derni√®re partie du chemin)
    const lastPart = pathParts[pathParts.length - 1].split('?')[0]; // Sans param√®tres
    console.log('üî• [DEBUG] - Nom de fichier:', lastPart);
    
    // 1. Approche bas√©e sur les patterns: Recherche de patterns connus dans le nom de fichier
    const signatureMatch = lastPart.match(/(participant|representative|trainer)_(\w+)_(\d+)\.png/);
    
    if (signatureMatch) {
      // Extraire les parties significatives
      const [_, signerType, docType, timestamp] = signatureMatch;
      console.log(`üî• [DEBUG] Signature identifi√©e: type=${signerType}, docType=${docType}, timestamp=${timestamp}`);
      
      // STRAT√âGIE 1: La structure de base originale que nous attendons (simple)
      const simpleUrl = `${host}/storage/v1/object/public/signatures/${signerType}_${docType}_${timestamp}.png`;
      console.log('üî• [DEBUG] URL simplifi√©e (strat√©gie 1):', simpleUrl);
      
      // STRAT√âGIE 2: Structure avec dossiers UUID et sous-dossier signatures
      // Cela correspond √† ce qu'on voit dans les logs d'erreur
      // Note: Cette structure est hypoth√©tique, d√©pend de votre configuration r√©elle
      if (pathname.includes('/signatures/signatures/')) {
        console.log('üî• [DEBUG] Structure avec duplication de signatures d√©tect√©e');
        
        // Trouver la position du dernier dossier "signatures"
        const lastSignaturesPos = pathname.lastIndexOf('/signatures/');
        if (lastSignaturesPos !== -1) {
          const prefix = pathname.substring(0, lastSignaturesPos);
          const complexUrl = `${host}${prefix}/signatures/${signerType}_${docType}_${timestamp}.png`;
          console.log('üî• [DEBUG] URL complexe avec structure de dossiers (strat√©gie 2):', complexUrl);
          return complexUrl;
        }
      }
      
      // STRAT√âGIE 3: Si l'URL contient des UUID, essayer de pr√©server la structure
      const uuidPattern = /\/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\//i;
      if (uuidPattern.test(pathname)) {
        console.log('üî• [DEBUG] Structure avec UUID d√©tect√©e');
        
        // R√©cup√©rer tous les segments UUID
        const uuidSegments: string[] = [];
        pathParts.forEach(part => {
          if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(part)) {
            uuidSegments.push(part);
          }
        });
        
        if (uuidSegments.length > 0) {
          console.log('üî• [DEBUG] Segments UUID trouv√©s:', uuidSegments);
          
          // Construire une URL avec la structure UUID mais le nom de fichier simplifi√©
          let uuidStructure = '/storage/v1/object/public/signatures';
          uuidSegments.forEach(uuid => {
            uuidStructure += `/${uuid}`;
          });
          
          const uuidUrl = `${host}${uuidStructure}/${signerType}_${docType}_${timestamp}.png`;
          console.log('üî• [DEBUG] URL avec structure UUID pr√©serv√©e (strat√©gie 3):', uuidUrl);
          return uuidUrl;
        }
      }
      
      // Par d√©faut, retourner l'URL simple
      return simpleUrl;
    }
    
    // Si nous n'avons pas pu extraire un identifiant temporel, essayer avec le nom complet
    const fullPath = `/storage/v1/object/public/signatures/${lastPart}`;
    const fullUrl = `${host}${fullPath}`;
    
    console.log('üî• [DEBUG] URL avec nom complet (aucun pattern reconnu):', fullUrl);
    return fullUrl;
    
  } catch (error) {
    console.error('üî• [DEBUG] Erreur lors de la normalisation de l\'URL:', error, url);
    return url;
  }
};

/**
 * Normalise une URL Supabase pour √©viter les erreurs 400 (version asynchrone)
 * Cette fonction est particuli√®rement utile pour les URLs de signatures qui peuvent
 * avoir une structure complexe de dossiers qui cause des probl√®mes.
 * 
 * @param url L'URL Supabase √† normaliser
 * @param supabaseInstance Instance de Supabase (optionnel, pour diagnostic avanc√©)
 * @returns Promise avec l'URL normalis√©e
 */
export const normalizeSupabaseUrlAsync = async (
  url: string | null | undefined, 
  supabaseInstance?: any
): Promise<string | null | undefined> => {
  if (!url) return url;
  
  // Si ce n'est pas une URL Supabase pour les signatures, retourner telle quelle
  if (!isSupabaseSignatureUrl(url)) return url;
  
  try {
    console.log('üî• [DEBUG] Normalisation d\'URL Supabase (async):', url);
    
    // Si l'instance Supabase est fournie, utiliser le diagnostic avanc√©
    if (supabaseInstance) {
      const diagnostic = await diagnoseSignatureUrl(supabaseInstance, url);
      
      if (diagnostic.exists && diagnostic.correctUrl) {
        console.log('üî• [DEBUG] URL correcte trouv√©e via diagnostic:', diagnostic.correctUrl);
        return diagnostic.correctUrl;
      }
    }
    
    // Si le diagnostic n'a pas fonctionn√©, utiliser la version synchrone
    return normalizeSupabaseUrl(url);
    
  } catch (error) {
    console.error('üî• [DEBUG] Erreur lors de la normalisation asynchrone de l\'URL:', error, url);
    return url;
  }
};

// D√©finir l'interface pour les fichiers Supabase
interface SupabaseStorageFile {
  name: string;
  id: string;
  created_at: string;
  updated_at: string;
  last_accessed_at: string;
  metadata: any;
  size: number;
}

/**
 * Recherche une signature dans le bucket Supabase √† partir de son identifiant timestamp
 * @param supabaseInstance Instance de Supabase (pour √©viter les probl√®mes de r√©f√©rence circulaire)
 * @param signerType Type de signataire (participant, representative, trainer)
 * @param timestamp Timestamp unique de la signature
 * @returns Promise avec l'URL compl√®te du fichier trouv√©, ou null si non trouv√©
 */
export const findRealSignatureFile = async (
  supabaseInstance: any,
  signerType: string,
  timestamp: string
): Promise<string | null> => {
  try {
    console.log(`üîç [DEBUG] Recherche du fichier de signature: type=${signerType}, timestamp=${timestamp}`);
    
    // Lister les fichiers du bucket "signatures"
    const { data: files, error } = await supabaseInstance.storage
      .from('signatures')
      .list('', { 
        limit: 100,
        sortBy: { column: 'created_at', order: 'desc' }
      });
    
    if (error) {
      console.error('üîç [DEBUG] Erreur lors de la liste des fichiers signatures:', error);
      return null;
    }
    
    if (!files || files.length === 0) {
      console.log('üîç [DEBUG] Aucun fichier dans le bucket signatures');
      return null;
    }
    
    console.log(`üîç [DEBUG] ${files.length} fichiers trouv√©s dans le bucket signatures`);
    
    // Rechercher un fichier qui contient le type de signataire et le timestamp
    const matchingFile = files.find((file: SupabaseStorageFile) => 
      file.name.includes(signerType) && 
      file.name.includes(timestamp) && 
      file.name.endsWith('.png')
    );
    
    if (matchingFile) {
      console.log(`üîç [DEBUG] Fichier correspondant trouv√©: ${matchingFile.name}`);
      
      // G√©n√©rer l'URL publique correcte avec le vrai nom de fichier
      const { data: urlData } = await supabaseInstance.storage
        .from('signatures')
        .getPublicUrl(matchingFile.name);
      
      if (urlData && urlData.publicUrl) {
        console.log(`üîç [DEBUG] URL publique g√©n√©r√©e: ${urlData.publicUrl}`);
        return urlData.publicUrl;
      }
    }
    
    console.log(`üîç [DEBUG] Aucun fichier correspondant pour: type=${signerType}, timestamp=${timestamp}`);
    return null;
  } catch (error) {
    console.error('üîç [DEBUG] Erreur lors de la recherche du fichier de signature:', error);
    return null;
  }
};

/**
 * V√©rifie directement si un fichier existe dans le bucket Supabase
 * @param supabaseInstance Instance de Supabase
 * @param signatureUrl URL de la signature √† v√©rifier
 * @returns Un objet contenant le r√©sultat et des informations de diagnostic
 */
export const diagnoseSignatureUrl = async (
  supabaseInstance: any,
  signatureUrl: string | null
): Promise<{exists: boolean; details: string; path?: string; actualFiles?: string[]; correctUrl?: string; rawResponse?: any}> => {
  if (!signatureUrl) {
    return {
      exists: false,
      details: "URL de signature manquante"
    };
  }

  try {
    console.log('üß® [DIAGNOSTIC] Diagnostic complet de l\'URL de signature:', signatureUrl);
    
    // Faire une requ√™te HEAD directe pour voir la r√©ponse exacte
    try {
      const response = await fetch(signatureUrl, { 
        method: 'HEAD',
        cache: 'no-store' 
      });
      
      console.log('üß® [DIAGNOSTIC] Statut de la r√©ponse HTTP:', response.status);
      console.log('üß® [DIAGNOSTIC] Type de r√©ponse:', response.type);
      
      // R√©cup√©rer tous les headers
      const headers: Record<string, string> = {};
      response.headers.forEach((value, key) => {
        headers[key] = value;
      });
      console.log('üß® [DIAGNOSTIC] Headers de r√©ponse:', headers);
      
      // Si c'est une erreur 400, essayer de faire un GET pour r√©cup√©rer le corps
      if (response.status === 400) {
        try {
          const getResponse = await fetch(signatureUrl, { method: 'GET' });
          const responseData = await getResponse.text();
          console.log('üß® [DIAGNOSTIC] Contenu de la r√©ponse 400:', responseData);
        } catch (e) {
          console.error('üß® [DIAGNOSTIC] Impossible de r√©cup√©rer le contenu de l\'erreur:', e);
        }
      }
    } catch (fetchError) {
      console.error('üß® [DIAGNOSTIC] Erreur lors du fetch direct:', fetchError);
    }
    
    // Extraire le nom du fichier attendu de l'URL
    const url = new URL(signatureUrl);
    const pathParts = url.pathname.split('/');
    const expectedFileName = pathParts[pathParts.length - 1].split('?')[0];
    
    console.log('üß® [DIAGNOSTIC] Analyse du chemin:');
    console.log('üß® [DIAGNOSTIC] URL compl√®te:', url.toString());
    console.log('üß® [DIAGNOSTIC] Hostname:', url.hostname);
    console.log('üß® [DIAGNOSTIC] Pathname complet:', url.pathname);
    console.log('üß® [DIAGNOSTIC] Parties du chemin:', pathParts);
    console.log('üß® [DIAGNOSTIC] Nom de fichier attendu:', expectedFileName);
    
    // D√©coder les parties de l'URL pour s'assurer qu'il n'y a pas de probl√®me d'encodage
    const decodedPathname = decodeURIComponent(url.pathname);
    console.log('üß® [DIAGNOSTIC] Chemin d√©cod√©:', decodedPathname);
    
    // Lister TOUS les fichiers du bucket sans filtre pour voir exactement ce qu'il contient
    const { data: allFiles, error: listAllError } = await supabaseInstance.storage
      .from('signatures')
      .list('', { 
        limit: 100,
        sortBy: { column: 'created_at', order: 'desc' }
      });
    
    if (listAllError) {
      console.error('üß® [DIAGNOSTIC] Erreur lors de la liste des fichiers:', listAllError);
    } else {
      console.log('üß® [DIAGNOSTIC] Contenu COMPLET du bucket signatures:');
      if (allFiles && allFiles.length > 0) {
        allFiles.forEach((file: SupabaseStorageFile, index: number) => {
          console.log(`üß® [DIAGNOSTIC] Fichier #${index + 1}:`, file.name);
        });
      } else {
        console.log('üß® [DIAGNOSTIC] Aucun fichier trouv√© dans le bucket signatures');
      }
    }
    
    // Rechercher dans le bucket si le fichier existe avec exactement ce nom
    const { data: exactMatch, error: exactMatchError } = await supabaseInstance.storage
      .from('signatures')
      .list('', {
        search: expectedFileName
      });
    
    if (exactMatchError) {
      console.error('üß® [DIAGNOSTIC] Erreur lors de la recherche exacte:', exactMatchError);
      return {
        exists: false,
        details: `Erreur lors de la recherche: ${exactMatchError.message}`,
        path: expectedFileName
      };
    }
    
    if (exactMatch && exactMatch.length > 0) {
      console.log('üß® [DIAGNOSTIC] Fichier trouv√© avec le nom exact:', exactMatch);
      
      // G√©n√©rer l'URL publique correcte
      const { data: urlData } = await supabaseInstance.storage
        .from('signatures')
        .getPublicUrl(exactMatch[0].name);
      
      if (urlData && urlData.publicUrl) {
        console.log('üß® [DIAGNOSTIC] URL publique correcte g√©n√©r√©e:', urlData.publicUrl);
        return {
          exists: true,
          details: "Le fichier existe dans le bucket",
          path: expectedFileName,
          correctUrl: urlData.publicUrl
        };
      }
    }
    
    // Extraire l'identifiant timestamp et le type de signataire de l'URL
    let timestamp: string | null = null;
    let signerType: string | null = null;
    
    // Essayer d'extraire le timestamp du nom de fichier
    const timestampMatch = expectedFileName.match(/_([\d]+)\.png/);
    if (timestampMatch && timestampMatch[1]) {
      timestamp = timestampMatch[1];
      console.log('üß® [DIAGNOSTIC] Timestamp extrait:', timestamp);
    }
    
    // Essayer d'extraire le type de signataire
    const signerTypeMatch = expectedFileName.match(/(participant|representative|trainer)_/);
    if (signerTypeMatch && signerTypeMatch[1]) {
      signerType = signerTypeMatch[1];
      console.log('üß® [DIAGNOSTIC] Type de signataire extrait:', signerType);
    }
    
    // Si nous avons un timestamp et un type de signataire, chercher des fichiers correspondants
    if (timestamp && signerType) {
      // Chercher parmi les fichiers r√©cents ceux qui contiennent le timestamp et le type de signataire
      const matchingFiles = allFiles.filter((file: SupabaseStorageFile) => 
        file.name.includes(timestamp as string) && 
        file.name.includes(signerType as string)
      );
      
      if (matchingFiles.length > 0) {
        console.log('üß® [DIAGNOSTIC] Fichiers correspondant au timestamp et type trouv√©s:', matchingFiles);
        console.log('üß® [DIAGNOSTIC] Noms des fichiers correspondants:');
        const fileNames = matchingFiles.map((f: SupabaseStorageFile) => f.name);
        fileNames.forEach((name: string, index: number) => {
          console.log(`üß® [DIAGNOSTIC] Correspondance #${index + 1}:`, name);
        });
        
        // G√©n√©rer l'URL publique correcte pour le premier fichier correspondant
        const { data: urlData } = await supabaseInstance.storage
          .from('signatures')
          .getPublicUrl(matchingFiles[0].name);
        
        if (urlData && urlData.publicUrl) {
          console.log('üß® [DIAGNOSTIC] URL publique correcte g√©n√©r√©e:', urlData.publicUrl);
          return {
            exists: true,
            details: `Fichier correspondant trouv√© avec le timestamp ${timestamp} et le type ${signerType}`,
            path: expectedFileName,
            actualFiles: fileNames,
            correctUrl: urlData.publicUrl
          };
        }
      }
    }
    
    // Si nous avons seulement un timestamp, chercher des fichiers correspondants
    if (timestamp) {
      const matchingFiles = allFiles.filter((file: SupabaseStorageFile) => 
        file.name.includes(timestamp as string)
      );
      
      if (matchingFiles.length > 0) {
        console.log('üß® [DIAGNOSTIC] Fichiers correspondant au timestamp trouv√©s:', matchingFiles);
        const fileNames = matchingFiles.map((f: SupabaseStorageFile) => f.name);
        
        // G√©n√©rer l'URL publique correcte pour le premier fichier correspondant
        const { data: urlData } = await supabaseInstance.storage
          .from('signatures')
          .getPublicUrl(matchingFiles[0].name);
        
        if (urlData && urlData.publicUrl) {
          console.log('üß® [DIAGNOSTIC] URL publique correcte g√©n√©r√©e (par timestamp):', urlData.publicUrl);
          return {
            exists: true,
            details: `Fichier correspondant trouv√© avec le timestamp ${timestamp}`,
            path: expectedFileName,
            actualFiles: fileNames,
            correctUrl: urlData.publicUrl
          };
        }
      }
    }
    
    // Aucune correspondance trouv√©e
    return {
      exists: false,
      details: `Le fichier ${expectedFileName} n'existe pas dans le bucket 'signatures'. ${allFiles?.length || 0} fichiers r√©cents list√©s.`,
      path: expectedFileName,
      actualFiles: allFiles?.map((f: SupabaseStorageFile) => f.name) || []
    };
    
  } catch (error) {
    console.error('üß® [DIAGNOSTIC] Erreur lors du diagnostic de l\'URL de signature:', error);
    return {
      exists: false,
      details: `Erreur: ${error instanceof Error ? error.message : String(error)}`
    };
  }
};

/**
 * Supprime toutes les sections intitul√©es "Signature du participant" d'un document
 * en pr√©servant celles qui sont explicitement plac√©es dans les templates unifi√©s
 * 
 * @param container √âl√©ment DOM contenant le document
 * @returns Nombre de sections supprim√©es
 */
export const removeAllParticipantSignatureSections = (container: HTMLElement): number => {
  if (!container) {
    console.log('üîç [DEBUG] removeAllParticipantSignatureSections: Aucun conteneur fourni');
    return 0;
  }

  console.log('üîç [DEBUG] Suppression des sections "Signature du participant" ind√©sirables');
  let removedCount = 0;

  // √âtape 1: V√©rifier si on est dans un template unifi√©
  const isUnifiedTemplate = container.classList.contains('unified-training-agreement');
  console.log(`üîç [DEBUG] Est-ce un template unifi√©? ${isUnifiedTemplate}`);
  
  // √âtape 2: Trouver tous les n≈ìuds de texte contenant "Signature du participant"
  const allTextNodes = getAllTextNodes(container);
  const signatureNodes = allTextNodes.filter(
    node => node.textContent && node.textContent.trim() === 'Signature du participant'
  );

  // √âtape 3: Pour chaque occurrence, supprimer la section parente appropri√©e
  signatureNodes.forEach(node => {
    // V√©rifier si ce n≈ìud est dans la section "Pour le stagiaire" ou signatures-section
    let isInProtectedSection = false;
    let currentNode: Node | null = node;
    
    // Remonter jusqu'√† 5 niveaux pour chercher un titre ou une classe prot√©g√©e
    for (let i = 0; i < 5 && currentNode; i++) {
      if (currentNode.nodeType === Node.ELEMENT_NODE) {
        const element = currentNode as HTMLElement;
        // V√©rifier les classes et attributs qui indiquent qu'il s'agit d'une section l√©gitime
        if (
          element.classList?.contains('signatures-section') ||
          element.hasAttribute('data-signature-container') ||
          element.hasAttribute('data-signature-type')
        ) {
          isInProtectedSection = true;
          break;
        }
      }
      
      // Si un parent contient le texte "Pour le stagiaire", ne pas supprimer
      if (currentNode.textContent && (
          currentNode.textContent.includes('Pour le stagiaire') ||
          currentNode.textContent.includes('Pour l\'entreprise') ||
          currentNode.textContent.includes('Pour l\'organisme de formation')
      )) {
        isInProtectedSection = true;
        break;
      }
      currentNode = currentNode.parentNode;
    }

    if (!isInProtectedSection) {
      // Trouver le parent √† supprimer (div, section, etc.)
      let target = node.parentElement;
      let foundTarget = false;
      
      // Remonter jusqu'√† 5 niveaux pour trouver une section ou div
      for (let i = 0; i < 5 && target; i++) {
        // Si c'est un √©l√©ment qui ressemble √† une section compl√®te
        if (
          target.tagName === 'DIV' || 
          target.tagName === 'SECTION' ||
          (target.className && (
            target.className.includes('signature') ||
            target.className.includes('mt-') ||
            target.className.includes('border-t')
          ))
        ) {
          foundTarget = true;
          break;
        }
        target = target.parentElement;
      }

      if (foundTarget && target) {
        console.log(`üîç [DEBUG] Suppression d'une section "Signature du participant": ${target.tagName}`);
        // Masquer d'abord, puis vider, puis supprimer
        (target as HTMLElement).style.display = 'none';
        target.innerHTML = '';
        if (target.parentElement) {
          target.parentElement.removeChild(target);
        }
        removedCount++;
      }
    } else {
      console.log('üîç [DEBUG] Section de signature d√©tect√©e dans une zone prot√©g√©e, conservation');
    }
  });

  // √âtape 4: Chercher aussi par attributs data, mais √©pargner les containers l√©gitimes
  const dataSignatureElements = container.querySelectorAll('[data-signature-type="participant"]');
  dataSignatureElements.forEach(element => {
    // V√©rifier si cet √©l√©ment est dans un conteneur prot√©g√©
    let isInProtectedSection = false;
    
    // V√©rifier si l'√©l√©ment lui-m√™me est un conteneur l√©gitime
    if (element.hasAttribute('data-signature-container')) {
      isInProtectedSection = true;
    } else {
      let currentNode: Node | null = element;
      
      // Remonter jusqu'√† 5 niveaux pour chercher un conteneur prot√©g√©
      for (let i = 0; i < 5 && currentNode; i++) {
        if (currentNode.nodeType === Node.ELEMENT_NODE) {
          const parentElement = currentNode as HTMLElement;
          if (
            parentElement.classList?.contains('signatures-section') ||
            parentElement.textContent?.includes('Pour le stagiaire')
          ) {
            isInProtectedSection = true;
            break;
          }
        }
        currentNode = currentNode.parentNode;
      }
    }

    if (!isInProtectedSection) {
      console.log(`üîç [DEBUG] Suppression d'un √©l√©ment avec data-signature-type="participant"`);
      (element as HTMLElement).style.display = 'none';
      element.innerHTML = '';
      element.parentElement?.removeChild(element);
      removedCount++;
    } else {
      console.log('üîç [DEBUG] Conteneur de signature data-* d√©tect√© dans une zone prot√©g√©e, conservation');
    }
  });

  console.log(`üîç [DEBUG] ${removedCount} sections "Signature du participant" supprim√©es`);
  return removedCount;
};

/**
 * Configure un conteneur de signature avec les attributs standardis√©s
 * 
 * @param container √âl√©ment DOM contenant le document
 * @param type Type de signature (participant, company, trainer)
 * @param headerText Texte d'en-t√™te identifiant la section (ex: "Pour le stagiaire")
 * @returns Le conteneur de signature configur√© ou null si non trouv√©
 */
export const setupSignatureContainer = (
  container: HTMLElement, 
  type: SignatureType, 
  headerText: string
): HTMLElement | null => {
  if (!container) {
    console.log(`üîç [DEBUG] setupSignatureContainer: Aucun conteneur fourni pour ${type}`);
    return null;
  }

  console.log(`üîç [DEBUG] Configuration du conteneur de signature pour "${headerText}"`);
  
  // √âtape 1: Chercher si un conteneur existe d√©j√† avec l'attribut data-*
  const existingContainers = container.querySelectorAll(`[data-signature-container="${type}"], [data-signature-type="${type}"]`);
  if (existingContainers.length > 0) {
    console.log(`üîç [DEBUG] Conteneur existant trouv√© pour ${type}`);
    return existingContainers[0] as HTMLElement;
  }
  
  // √âtape 2: Chercher par texte d'en-t√™te
  const textNodes = getAllTextNodes(container);
  const headerNodes = textNodes.filter(node => 
    node.textContent && node.textContent.trim() === headerText
  );
  
  if (headerNodes.length === 0) {
    console.log(`üîç [DEBUG] Aucun en-t√™te "${headerText}" trouv√©`);
    return null;
  }
  
  // Prendre le premier en-t√™te trouv√©
  const headerNode = headerNodes[0];
  let headerElement = headerNode.parentElement;
  
  // √âtape 3: Trouver le conteneur de signature proche de l'en-t√™te
  let signatureContainer: HTMLElement | null = null;
  
  // Remonter jusqu'√† 3 niveaux pour trouver un parent commun
  let commonParent = headerElement;
  for (let i = 0; i < 3 && commonParent; i++) {
    // Chercher une div avec une bordure (probablement le conteneur de signature)
    const potentialContainers = commonParent.querySelectorAll('.border, [style*="border"]');
    
    for (const container of potentialContainers) {
      // V√©rifier que c'est une div de taille raisonnable (probablement un cadre de signature)
      const rect = container.getBoundingClientRect();
      if (rect.height > 20 && rect.width > 50) {
        signatureContainer = container as HTMLElement;
        break;
      }
    }
    
    if (signatureContainer) break;
    commonParent = commonParent?.parentElement;
  }
  
  // Si aucun conteneur trouv√©, chercher n'importe quelle div qui pourrait convenir
  if (!signatureContainer && headerElement?.parentElement) {
    const parentDiv = headerElement.parentElement;
    const divs = parentDiv.querySelectorAll('div');
    
    // Parcourir les divs et prendre la premi√®re qui semble appropri√©e
    for (const div of divs) {
      if (div.children.length === 0 || div.textContent?.trim() === '') {
        signatureContainer = div as HTMLElement;
        break;
      }
    }
  }
  
  // √âtape 4: Si un conteneur a √©t√© trouv√©, le configurer
  if (signatureContainer) {
    console.log(`üîç [DEBUG] Conteneur de signature trouv√© et configur√© pour ${type}`);
    
    // Ajouter les attributs data-* standardis√©s
    signatureContainer.setAttribute('data-signature-container', type);
    signatureContainer.setAttribute('data-signature-type', type);
    
    // Ajouter des classes CSS si n√©cessaire
    if (!signatureContainer.classList.contains('border')) {
      signatureContainer.classList.add('border', 'border-gray-300');
    }
    
    if (!signatureContainer.style.height) {
      signatureContainer.style.height = '100px';
    }
    
    return signatureContainer;
  }
  
  console.log(`üîç [DEBUG] Aucun conteneur trouv√© pour ${type}`);
  return null;
};

/**
 * Pr√©charge une image de signature et l'ins√®re dans le conteneur appropri√©
 * 
 * @param signatureUrl URL de l'image de signature
 * @param type Type de signature (participant, company, trainer)
 * @param container √âl√©ment DOM contenant le document
 * @returns true si l'image a √©t√© charg√©e avec succ√®s, false sinon
 */
export const preloadSignatureImage = (
  signatureUrl: string | null | undefined,
  type: SignatureType,
  container: HTMLElement = document.body
): boolean => {
  if (!signatureUrl) {
    console.log(`üîç [DEBUG] preloadSignatureImage: Aucune URL fournie pour ${type}`);
    return false;
  }

  console.log(`üîç [DEBUG] Pr√©chargement de la signature ${type}: ${signatureUrl}`);
  
  // √âtape 1: Trouver les conteneurs de signature correspondants
  const signatureContainers = Array.from(container.querySelectorAll(
    `[data-signature-container="${type}"], [data-signature-type="${type}"]`
  )) as HTMLElement[];
  
  if (signatureContainers.length === 0) {
    console.log(`üîç [DEBUG] Aucun conteneur trouv√© pour la signature ${type}`);
    return false;
  }
  
  // √âtape 2: Ajouter un timestamp pour √©viter le cache
  const antiCacheUrl = addAntiCacheToUrl(signatureUrl);
  
  // √âtape 3: Pr√©charger l'image
  const img = new Image();
  let loaded = false;
  
  img.onload = () => {
    console.log(`üîç [DEBUG] Image de signature ${type} charg√©e avec succ√®s`);
    loaded = true;
    
    // √âtape 4: Ins√©rer l'image dans tous les conteneurs trouv√©s
    signatureContainers.forEach(container => {
      // Vider le conteneur
      container.innerHTML = '';
      
      // Cr√©er un wrapper pour centrer l'image
      const wrapper = document.createElement('div');
      wrapper.className = 'w-full h-full flex items-center justify-center';
      wrapper.dataset.signatureWrapper = type;
      
      // Cr√©er une copie de l'image pour chaque conteneur
      const imgCopy = document.createElement('img');
      imgCopy.src = antiCacheUrl;
      imgCopy.alt = `Signature ${type}`;
      imgCopy.className = 'max-h-20 max-w-[95%] object-contain';
      imgCopy.dataset.signatureImage = type;
      imgCopy.dataset.signatureSrc = signatureUrl;
      
      wrapper.appendChild(imgCopy);
      container.appendChild(wrapper);
    });
  };
  
  img.onerror = () => {
    console.error(`üîç [ERROR] √âchec du chargement de l'image de signature ${type}`);
    console.log(`üîç [DEBUG] URL qui a √©chou√©: ${antiCacheUrl}`);
    
    // Essayer sans les param√®tres anti-cache
    const retryImg = new Image();
    retryImg.onload = () => {
      console.log(`üîç [DEBUG] Image de signature ${type} charg√©e avec succ√®s (seconde tentative)`);
      loaded = true;
      
      // Ins√©rer l'image dans tous les conteneurs trouv√©s
      signatureContainers.forEach(container => {
        container.innerHTML = '';
        
        const wrapper = document.createElement('div');
        wrapper.className = 'w-full h-full flex items-center justify-center';
        wrapper.dataset.signatureWrapper = type;
        
        const imgCopy = document.createElement('img');
        imgCopy.src = signatureUrl;
        imgCopy.alt = `Signature ${type}`;
        imgCopy.className = 'max-h-20 max-w-[95%] object-contain';
        imgCopy.dataset.signatureImage = type;
        imgCopy.dataset.signatureSrc = signatureUrl;
        
        wrapper.appendChild(imgCopy);
        container.appendChild(wrapper);
      });
    };
    
    retryImg.onerror = () => {
      console.error(`üîç [ERROR] √âchec du chargement de l'image de signature ${type} (seconde tentative)`);
    };
    
    retryImg.src = signatureUrl;
  };
  
  img.src = antiCacheUrl;
  return true;
};

/**
 * V√©rifie si une URL de signature existe et est accessible
 * 
 * @param signatureUrl URL de l'image √† v√©rifier
 * @returns Promise<boolean> true si l'URL est valide et accessible
 */
export const verifySignatureUrl = async (signatureUrl: string | null | undefined): Promise<boolean> => {
  if (!signatureUrl) return false;
  
  try {
    console.log(`üîç [DEBUG] V√©rification de l'URL de signature: ${signatureUrl}`);
    
    // Extraire l'URL de base sans param√®tres
    const baseUrl = signatureUrl.split('?')[0];
    
    // Faire une requ√™te HEAD pour v√©rifier si l'URL est accessible
    const response = await fetch(baseUrl, { 
      method: 'HEAD', 
      cache: 'no-store',
      credentials: 'omit'
    });
    
    const isValid = response.ok;
    console.log(`üîç [DEBUG] URL de signature ${isValid ? 'valide' : 'invalide'}: ${signatureUrl}`);
    
    return isValid;
  } catch (error) {
    console.error(`üîç [ERROR] Erreur lors de la v√©rification de l'URL: ${error}`);
    return false;
  }
};

/**
 * Ajoute des param√®tres anti-cache √† une URL
 * 
 * @param url URL √† modifier
 * @returns URL modifi√©e avec des param√®tres anti-cache
 */
export const addAntiCacheToUrl = (url: string | null | undefined): string => {
  if (!url) return '';
  
  // Si l'URL contient d√©j√† des param√®tres anti-cache, la retourner telle quelle
  if (url.includes('nocache=') || url.includes('t=')) {
    return url;
  }
  
  // Ajouter des param√®tres anti-cache
  const separator = url.includes('?') ? '&' : '?';
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 8);
  
  return `${url}${separator}t=${timestamp}&r=${random}&nocache=true`;
};

/**
 * R√©cup√®re tous les n≈ìuds de texte d'un √©l√©ment DOM
 * 
 * @param element √âl√©ment DOM √† parcourir
 * @returns Tableau de n≈ìuds de texte
 */
const getAllTextNodes = (element: Node): Text[] => {
  const textNodes: Text[] = [];
  
  // Fonction r√©cursive pour parcourir l'arbre DOM
  const traverse = (node: Node) => {
    if (node.nodeType === Node.TEXT_NODE && node.textContent?.trim()) {
      textNodes.push(node as Text);
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      for (let i = 0; i < node.childNodes.length; i++) {
        traverse(node.childNodes[i]);
      }
    }
  };
  
  traverse(element);
  return textNodes;
};

// Exporter un objet pour faciliter l'importation
export const SignatureUtils = {
  removeAllParticipantSignatureSections,
  setupSignatureContainer,
  preloadSignatureImage,
  verifySignatureUrl,
  addAntiCacheToUrl,
};

export default SignatureUtils; 