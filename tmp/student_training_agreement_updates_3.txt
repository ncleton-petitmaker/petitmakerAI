// 6. Fonction handleSignatureSave √† remplacer (vers la ligne 1842)
const handleSignatureSave = async (signatureDataUrl: string, type: SignatureType | 'participant' | 'companySeal' | 'representative' = SignatureType.PARTICIPANT) => {
  // V√©rifier l'authentification
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) {
    alert('Vous devez √™tre connect√© pour signer ce document.');
    return;
  }
  
  if (isSaving) return;
  setIsSaving(true);
  
  // Emp√™cher la fermeture accidentelle de la page pendant l'enregistrement
  const preventUnload = (e: BeforeUnloadEvent) => {
    e.preventDefault();
    e.returnValue = 'Enregistrement en cours. √ätes-vous s√ªr de vouloir quitter?';
  };
  window.addEventListener('beforeunload', preventUnload);
  
  try {
    // Convertir le type si n√©cessaire
    const signatureType = typeof type === 'string' ? getSignatureTypeFromString(type) : type;
    
    console.log(`üîç [SAVE] Sauvegarde du ${isSealType(signatureType) ? 'tampon' : 'signature'} directement dans storage puis dans document_signatures`);
    
    try {
      // G√©n√©ration d'un nom unique pour le fichier de signature
      const timestamp = Date.now();
      const userId = participant.id;
      const trainingId = training.id;
      
      // Utiliser la fonction standardis√©e pour g√©n√©rer le nom du fichier
      const fileName = generateStandardSignatureFilename(
        signatureType,
        DocumentType.CONVENTION,
        trainingId,
        userId
      );
      
      console.log(`üîç [SAVE] Enregistrement du fichier dans storage avec nom: ${fileName}`);
      
      // 1. Enregistrer d'abord le fichier dans le bucket storage
      const { data: uploadData, error: uploadError } = await supabase.storage
        .from('signatures')
        .upload(fileName, 
          // Convertir le data URL en Blob
          await (await fetch(signatureDataUrl)).blob(), 
          { contentType: 'image/png', upsert: true });
      
      if (uploadError) {
        throw new Error(`Erreur lors de l'upload du fichier: ${uploadError.message}`);
      }
      
      console.log('‚úÖ [SAVE] Fichier enregistr√© avec succ√®s dans le bucket:', uploadData);
      
      // 2. R√©cup√©rer l'URL publique du fichier
      const { data: urlData } = await supabase.storage
        .from('signatures')
        .getPublicUrl(fileName);
      
      if (!urlData || !urlData.publicUrl) {
        throw new Error("Impossible d'obtenir l'URL publique du fichier");
      }
      
      const publicUrl = urlData.publicUrl;
      console.log('‚úÖ [SAVE] URL publique g√©n√©r√©e:', publicUrl);
      
      // 3. Enregistrer l'entr√©e dans document_signatures
      const { data: signatureData, error: signatureError } = await supabase
        .from('document_signatures')
        .insert([{
          user_id: participant.id,
          signature_url: publicUrl,
          signature_type: signatureType.toLowerCase(),
          training_id: training.id,
          type: DocumentType.CONVENTION,
          path: fileName,
          created_by: session.user.id
        }])
        .select();
      
      if (signatureError) {
        console.error('‚ùå [SAVE] Erreur lors de l\'enregistrement dans document_signatures:', signatureError);
        throw new Error(`Erreur lors de l'enregistrement dans document_signatures: ${signatureError.message}`);
      }
      
      console.log('‚úÖ [SAVE] Signature enregistr√©e dans document_signatures:', signatureData);
      
      // 4. Anticacher l'URL
      const antiCacheUrl = `${publicUrl.split('?')[0]}?t=${timestamp}&forcereload=true`;
      
      // 5. Pr√©charger l'image avant de mettre √† jour l'interface
      const img = new Image();
      img.onload = () => {
        console.log(`‚úÖ [SAVE] Image de ${isSealType(signatureType) ? 'tampon' : 'signature'} pr√©charg√©e avec succ√®s`);
        
        // Mettre √† jour les √©tats selon le type
        if (signatureType === SignatureType.COMPANY_SEAL) {
          safeSetCompanySeal(antiCacheUrl);
          toast.success('Tampon appliqu√© avec succ√®s !');
        } else if (signatureType === SignatureType.REPRESENTATIVE) {
          safeSetRepresentativeSignature(antiCacheUrl);
          setIsSigned(true);
          setHasRepresentativeSignature(true);
          toast.success('Signature du repr√©sentant l√©gal enregistr√©e avec succ√®s !');
          
          // Mettre √† jour le statut dans user_profiles si n√©cessaire
          supabase.from('user_profiles')
            .update({ has_signed_agreement: true })
            .eq('user_id', participant.id)
            .then(({ error }) => {
              if (error) {
                console.error('‚ùå [SAVE] Erreur lors de la mise √† jour du statut has_signed_agreement:', error);
              } else {
                console.log('‚úÖ [SAVE] Statut has_signed_agreement mis √† jour avec succ√®s');
              }
            });
        } else {
          // Pour une signature normale de participant
          safeSetParticipantSignature(antiCacheUrl);
          setIsSigned(true);
          setHasParticipantSignature(true);
          toast.success('Signature enregistr√©e avec succ√®s !');
          
          // Mettre √† jour le statut dans user_profiles
          supabase.from('user_profiles')
            .update({ has_signed_agreement: true })
            .eq('user_id', participant.id)
            .then(({ error }) => {
              if (error) {
                console.error('‚ùå [SAVE] Erreur lors de la mise √† jour du statut has_signed_agreement:', error);
              } else {
                console.log('‚úÖ [SAVE] Statut has_signed_agreement mis √† jour avec succ√®s');
              }
            });
        }
        
        // Mettre √† jour le cache global avec la nouvelle signature
        updateSignatureCache(
          signatureType === SignatureType.PARTICIPANT ? antiCacheUrl : participantSignature,
          signatureType === SignatureType.COMPANY_SEAL ? antiCacheUrl : companySeal,
          organizationSeal,
          trainerSignature,
          signatureType === SignatureType.REPRESENTATIVE ? antiCacheUrl : representativeSignature
        );
        
        // Activer la g√©n√©ration du PDF
        setCanGeneratePDF(true);
        
        // Afficher la confetti si c'est une signature de participant ou repr√©sentant
        if (signatureType === SignatureType.PARTICIPANT || signatureType === SignatureType.REPRESENTATIVE) {
          setShowConfetti(true);
          setTimeout(() => {
            setShowConfetti(false);
          }, 5000);
        }
      };
      
      img.onerror = (error) => {
        console.error('‚ùå [SAVE] Erreur lors du pr√©chargement de l\'image:', error);
        
        // En cas d'erreur de pr√©chargement, on met quand m√™me √† jour les √©tats
        if (signatureType === SignatureType.COMPANY_SEAL) {
          safeSetCompanySeal(antiCacheUrl);
        } else if (signatureType === SignatureType.REPRESENTATIVE) {
          safeSetRepresentativeSignature(antiCacheUrl);
          setIsSigned(true);
          setHasRepresentativeSignature(true);
        } else {
          safeSetParticipantSignature(antiCacheUrl);
          setIsSigned(true);
          setHasParticipantSignature(true);
        }
        
        // Mettre √† jour le cache global
        updateSignatureCache(
          signatureType === SignatureType.PARTICIPANT ? antiCacheUrl : participantSignature,
          signatureType === SignatureType.COMPANY_SEAL ? antiCacheUrl : companySeal,
          organizationSeal,
          trainerSignature,
          signatureType === SignatureType.REPRESENTATIVE ? antiCacheUrl : representativeSignature
        );
      };
      
      // D√©clencher le chargement de l'image
      img.src = antiCacheUrl;
    } catch (error: any) {
      console.error('‚ùå [SAVE] Erreur lors de la sauvegarde de la signature:', error);
      toast.error(`Erreur lors de la sauvegarde: ${error.message}`);
    }
  } catch (error: any) {
    console.error('‚ùå [SAVE] Erreur globale:', error);
    toast.error(`Une erreur est survenue: ${error.message}`);
  } finally {
    // Supprimer l'√©couteur d'√©v√©nement beforeunload
    window.removeEventListener('beforeunload', preventUnload);
    setIsSaving(false);
  }
}; 