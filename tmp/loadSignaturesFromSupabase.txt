const loadSignaturesFromSupabase = async () => {
  try {
    // V√©rifier si nous avons charg√© les signatures r√©cemment
    const now = Date.now();
    const timeSinceLastLoad = now - lastSignatureLoadTimeRef.current;
    
    // Si moins de 5 secondes se sont √©coul√©es, ne pas recharger
    if (timeSinceLastLoad < 5000 && 
        (participantSignature || companySeal || representativeSignature) && 
        lastSignatureLoadTimeRef.current > 0) {
      console.log('‚è±Ô∏è [LOAD] Chargement des signatures ignor√© (derni√®re charge < 5s)');
      return;
    }
    
    // Marquer le temps de chargement
    lastSignatureLoadTimeRef.current = now;
    console.log('üîç [LOAD] Chargement des signatures depuis Supabase...');
    
    // R√©cup√©rer les signatures de participant depuis document_signatures
    const { data: participantSigData, error: participantSigError } = await supabase
      .from('document_signatures')
      .select('*')
      .eq('user_id', participant.id)
      .eq('training_id', training.id)
      .eq('type', 'convention')
      .eq('signature_type', 'participant')
      .order('created_at', { ascending: false })
      .limit(1);
    
    if (participantSigError) {
      console.error('‚ùå [LOAD] Erreur lors de la r√©cup√©ration de la signature du participant:', participantSigError);
    } else if (participantSigData && participantSigData.length > 0) {
      const sigUrl = optimizeSealUrl(participantSigData[0].signature_url);
      console.log('‚úÖ [LOAD] Signature du participant trouv√©e:', sigUrl);
      safeSetParticipantSignature(sigUrl);
      setHasParticipantSignature(true);
    } else {
      console.log('‚ÑπÔ∏è [LOAD] Aucune signature de participant trouv√©e');
      safeSetParticipantSignature(null);
    }
    
    // R√©cup√©rer les signatures de repr√©sentant depuis document_signatures
    const { data: representativeSigData, error: representativeSigError } = await supabase
      .from('document_signatures')
      .select('*')
      .eq('user_id', participant.id)
      .eq('training_id', training.id)
      .eq('type', 'convention')
      .eq('signature_type', 'representative')
      .order('created_at', { ascending: false })
      .limit(1);
    
    if (representativeSigError) {
      console.error('‚ùå [LOAD] Erreur lors de la r√©cup√©ration de la signature du repr√©sentant:', representativeSigError);
    } else if (representativeSigData && representativeSigData.length > 0) {
      const sigUrl = optimizeSealUrl(representativeSigData[0].signature_url);
      console.log('‚úÖ [LOAD] Signature du repr√©sentant trouv√©e:', sigUrl);
      safeSetRepresentativeSignature(sigUrl);
      setHasRepresentativeSignature(true);
    } else {
      console.log('‚ÑπÔ∏è [LOAD] Aucune signature de repr√©sentant trouv√©e');
      safeSetRepresentativeSignature(null);
    }
    
    // R√©cup√©rer le tampon d'entreprise depuis document_signatures
    const { data: companySealData, error: companySealError } = await supabase
      .from('document_signatures')
      .select('*')
      .eq('user_id', participant.id)
      .eq('training_id', training.id)
      .eq('type', 'convention')
      .eq('signature_type', 'companyseal')
      .order('created_at', { ascending: false })
      .limit(1);
    
    if (companySealError) {
      console.error('‚ùå [LOAD] Erreur lors de la r√©cup√©ration du tampon d\'entreprise:', companySealError);
    } else if (companySealData && companySealData.length > 0) {
      const sealUrl = optimizeSealUrl(companySealData[0].signature_url);
      console.log('‚úÖ [LOAD] Tampon d\'entreprise trouv√©:', sealUrl);
      safeSetCompanySeal(sealUrl);
    } else {
      console.log('‚ÑπÔ∏è [LOAD] Aucun tampon d\'entreprise trouv√©');
      safeSetCompanySeal(null);
    }
    
    // Si une signature est pr√©sente, on consid√®re que la convention est sign√©e
    const isSigned = !!participantSignature || !!representativeSignature;
    setIsSigned(isSigned);
    
    // R√©cup√©rer le tampon de l'organisme
    const orgSeal = await fetchOrganizationSeal();
    
    // R√©cup√©rer la signature du formateur
    const trainerSig = await loadTrainerSignature();
    
    // Mettre √† jour le cache global
    updateSignatureCache(
      participantSignature, 
      companySeal, 
      orgSeal, 
      trainerSig,
      representativeSignature
    );
    
    console.log('‚úÖ [LOAD] Chargement des signatures termin√©');
  } catch (error) {
    console.error('‚ùå [LOAD] Erreur lors du chargement des signatures:', error);
  }
}; 