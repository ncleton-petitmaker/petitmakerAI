import { SignatureType, DocumentType, getSignatureTypeFromString, isSealType, generateStandardSignatureFilename } from '../types/SignatureTypes';

interface SignatureCacheItem {
  participantSig?: string | null;
  companySeal?: string | null;
  organizationSeal?: string | null;
  trainerSig?: string | null;
  representativeSig?: string | null;
  timestamp?: number;
}

const [hasRepresentativeSignature, setHasRepresentativeSignature] = useState(false);

const safeSetRepresentativeSignature = useCallback((value: string | null) => {
  if (value || !signaturesLocked) {
    setRepresentativeSignature(value);
  } else {
    console.log('üîí [PROTECT] Tentative de d√©finir representativeSignature √† null bloqu√©e');
  }
}, [signaturesLocked]);

const updateSignatureCache = (participantSig: string | null, companySeal: string | null, organizationSeal: string | null, trainerSig: string | null, representativeSig: string | null) => {
  try {
    GLOBAL_SIGNATURE_CACHE.setCache(training.id, participant.id, {
      participantSig,
      companySeal,
      organizationSeal,
      trainerSig,
      representativeSig
    });
    
    const localStorageKey = `signatures_cache_${training.id}_${participant.id}`;
    const cacheData = {
      participantSig,
      companySeal,
      organizationSeal,
      trainerSig,
      representativeSig
    };
    localStorage.setItem(localStorageKey, JSON.stringify(cacheData));
    
    console.log('üîÑ [CACHE] Cache de signatures mis √† jour:', cacheData);
  } catch (e) {
    console.error('‚ùå [CACHE] Erreur lors de la mise √† jour du cache:', e);
  }
};

const handleSignatureSave = async (signatureDataUrl: string, type: SignatureType | 'participant' | 'companySeal' | 'representative' = SignatureType.PARTICIPANT) => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) {
    alert('Vous devez √™tre connect√© pour signer ce document.');
    return;
  }
  
  if (isSaving) return;
  setIsSaving(true);
  
  const preventUnload = (e: BeforeUnloadEvent) => {
    e.preventDefault();
    e.returnValue = 'Enregistrement en cours. √ätes-vous s√ªr de vouloir quitter?';
  };
  window.addEventListener('beforeunload', preventUnload);
  
  try {
    const signatureType = typeof type === 'string' ? getSignatureTypeFromString(type) : type;
    
    console.log(`üîç [SAVE] Sauvegarde du ${isSealType(signatureType) ? 'tampon' : 'signature'} directement dans storage puis dans document_signatures`);
    
    try {
      const timestamp = Date.now();
      const userId = participant.id;
      const trainingId = training.id;
      
      const fileName = generateStandardSignatureFilename(
        signatureType,
        DocumentType.CONVENTION,
        trainingId,
        userId
      );
      
      console.log(`üîç [SAVE] Enregistrement du fichier dans storage avec nom: ${fileName}`);
      
      const { data: uploadData, error: uploadError } = await supabase.storage
        .from('signatures')
        .upload(fileName, 
          await (await fetch(signatureDataUrl)).blob(), 
          { contentType: 'image/png', upsert: true });
      
      if (uploadError) {
        throw new Error(`Erreur lors de l'upload du fichier: ${uploadError.message}`);
      }
      
      console.log('‚úÖ [SAVE] Fichier enregistr√© avec succ√®s dans le bucket:', uploadData);
      
      const { data: urlData } = await supabase.storage
        .from('signatures')
        .getPublicUrl(fileName);
      
      if (!urlData || !urlData.publicUrl) {
        throw new Error("Impossible d'obtenir l'URL publique du fichier");
      }
      
      const publicUrl = urlData.publicUrl;
      console.log('‚úÖ [SAVE] URL publique g√©n√©r√©e:', publicUrl);
      
      const { data: signatureData, error: signatureError } = await supabase
        .from('document_signatures')
        .insert([{
          user_id: participant.id,
          signature_url: publicUrl,
          signature_type: signatureType.toLowerCase(),
          training_id: training.id,
          type: DocumentType.CONVENTION,
          path: fileName,
          created_by: session.user.id
        }])
        .select();
      
      if (signatureError) {
        console.error('‚ùå [SAVE] Erreur lors de l\'enregistrement dans document_signatures:', signatureError);
        throw new Error(`Erreur lors de l'enregistrement dans document_signatures: ${signatureError.message}`);
      }
      
      console.log('‚úÖ [SAVE] Signature enregistr√©e dans document_signatures:', signatureData);
      
      const antiCacheUrl = `${publicUrl.split('?')[0]}?t=${timestamp}&forcereload=true`;
      
      const img = new Image();
      img.onload = () => {
        console.log(`‚úÖ [SAVE] Image de ${isSealType(signatureType) ? 'tampon' : 'signature'} pr√©charg√©e avec succ√®s`);
        
        if (signatureType === SignatureType.COMPANY_SEAL) {
          safeSetCompanySeal(antiCacheUrl);
          toast.success('Tampon appliqu√© avec succ√®s !');
        } else if (signatureType === SignatureType.REPRESENTATIVE) {
          safeSetRepresentativeSignature(antiCacheUrl);
          setIsSigned(true);
          setHasRepresentativeSignature(true);
          toast.success('Signature du repr√©sentant l√©gal enregistr√©e avec succ√®s !');
          
          supabase.from('user_profiles')
            .update({ has_signed_agreement: true })
            .eq('user_id', participant.id)
            .then(({ error }) => {
              if (error) {
                console.error('‚ùå [SAVE] Erreur lors de la mise √† jour du statut has_signed_agreement:', error);
              } else {
                console.log('‚úÖ [SAVE] Statut has_signed_agreement mis √† jour avec succ√®s');
              }
            });
        } else {
          safeSetParticipantSignature(antiCacheUrl);
          setIsSigned(true);
          setHasParticipantSignature(true);
          toast.success('Signature enregistr√©e avec succ√®s !');
          
          supabase.from('user_profiles')
            .update({ has_signed_agreement: true })
            .eq('user_id', participant.id)
            .then(({ error }) => {
              if (error) {
                console.error('‚ùå [SAVE] Erreur lors de la mise √† jour du statut has_signed_agreement:', error);
              } else {
                console.log('‚úÖ [SAVE] Statut has_signed_agreement mis √† jour avec succ√®s');
              }
            });
        }
        
        updateSignatureCache(
          signatureType === SignatureType.PARTICIPANT ? antiCacheUrl : participantSignature,
          signatureType === SignatureType.COMPANY_SEAL ? antiCacheUrl : companySeal,
          organizationSeal,
          trainerSignature,
          signatureType === SignatureType.REPRESENTATIVE ? antiCacheUrl : representativeSignature
        );
        
        setCanGeneratePDF(true);
        
        if (signatureType === SignatureType.PARTICIPANT || signatureType === SignatureType.REPRESENTATIVE) {
          setShowConfetti(true);
          setTimeout(() => {
            setShowConfetti(false);
          }, 5000);
        }
      };
      
      img.onerror = (error) => {
        console.error('‚ùå [SAVE] Erreur lors du pr√©chargement de l\'image:', error);
        
        if (signatureType === SignatureType.COMPANY_SEAL) {
          safeSetCompanySeal(antiCacheUrl);
        } else if (signatureType === SignatureType.REPRESENTATIVE) {
          safeSetRepresentativeSignature(antiCacheUrl);
          setIsSigned(true);
          setHasRepresentativeSignature(true);
        } else {
          safeSetParticipantSignature(antiCacheUrl);
          setIsSigned(true);
          setHasParticipantSignature(true);
        }
        
        updateSignatureCache(
          signatureType === SignatureType.PARTICIPANT ? antiCacheUrl : participantSignature,
          signatureType === SignatureType.COMPANY_SEAL ? antiCacheUrl : companySeal,
          organizationSeal,
          trainerSignature,
          signatureType === SignatureType.REPRESENTATIVE ? antiCacheUrl : representativeSignature
        );
      };
      
      img.src = antiCacheUrl;
    } catch (error: any) {
      console.error('‚ùå [SAVE] Erreur lors de la sauvegarde de la signature:', error);
      toast.error(`Erreur lors de la sauvegarde: ${error.message}`);
    }
  } catch (error: any) {
    console.error('‚ùå [SAVE] Erreur globale:', error);
    toast.error(`Une erreur est survenue: ${error.message}`);
  } finally {
    window.removeEventListener('beforeunload', preventUnload);
    setIsSaving(false);
  }
};

const loadSignaturesFromSupabase = async () => {
  try {
    const now = Date.now();
    const timeSinceLastLoad = now - lastSignatureLoadTimeRef.current;
    
    if (timeSinceLastLoad < 5000 && 
        (participantSignature || companySeal || representativeSignature) && 
        lastSignatureLoadTimeRef.current > 0) {
      console.log('‚è±Ô∏è [LOAD] Chargement des signatures ignor√© (derni√®re charge < 5s)');
      return;
    }
    
    lastSignatureLoadTimeRef.current = now;
    console.log('üîç [LOAD] Chargement des signatures depuis Supabase...');
    
    const { data: participantSigData, error: participantSigError } = await supabase
      .from('document_signatures')
      .select('*')
      .eq('user_id', participant.id)
      .eq('training_id', training.id)
      .eq('type', 'convention')
      .eq('signature_type', 'participant')
      .order('created_at', { ascending: false })
      .limit(1);
    
    if (participantSigError) {
      console.error('‚ùå [LOAD] Erreur lors de la r√©cup√©ration de la signature du participant:', participantSigError);
    } else if (participantSigData && participantSigData.length > 0) {
      const sigUrl = optimizeSealUrl(participantSigData[0].signature_url);
      console.log('‚úÖ [LOAD] Signature du participant trouv√©e:', sigUrl);
      safeSetParticipantSignature(sigUrl);
      setHasParticipantSignature(true);
    } else {
      console.log('‚ÑπÔ∏è [LOAD] Aucune signature de participant trouv√©e');
      safeSetParticipantSignature(null);
    }
    
    const { data: representativeSigData, error: representativeSigError } = await supabase
      .from('document_signatures')
      .select('*')
      .eq('user_id', participant.id)
      .eq('training_id', training.id)
      .eq('type', 'convention')
      .eq('signature_type', 'representative')
      .order('created_at', { ascending: false })
      .limit(1);
    
    if (representativeSigError) {
      console.error('‚ùå [LOAD] Erreur lors de la r√©cup√©ration de la signature du repr√©sentant:', representativeSigError);
    } else if (representativeSigData && representativeSigData.length > 0) {
      const sigUrl = optimizeSealUrl(representativeSigData[0].signature_url);
      console.log('‚úÖ [LOAD] Signature du repr√©sentant trouv√©e:', sigUrl);
      safeSetRepresentativeSignature(sigUrl);
      setHasRepresentativeSignature(true);
    } else {
      console.log('‚ÑπÔ∏è [LOAD] Aucune signature de repr√©sentant trouv√©e');
      safeSetRepresentativeSignature(null);
    }
    
    const { data: companySealData, error: companySealError } = await supabase
      .from('document_signatures')
      .select('*')
      .eq('user_id', participant.id)
      .eq('training_id', training.id)
      .eq('type', 'convention')
      .eq('signature_type', 'companyseal')
      .order('created_at', { ascending: false })
      .limit(1);
    
    if (companySealError) {
      console.error('‚ùå [LOAD] Erreur lors de la r√©cup√©ration du tampon d\'entreprise:', companySealError);
    } else if (companySealData && companySealData.length > 0) {
      const sealUrl = optimizeSealUrl(companySealData[0].signature_url);
      console.log('‚úÖ [LOAD] Tampon d\'entreprise trouv√©:', sealUrl);
      safeSetCompanySeal(sealUrl);
    } else {
      console.log('‚ÑπÔ∏è [LOAD] Aucun tampon d\'entreprise trouv√©');
      safeSetCompanySeal(null);
    }
    
    const isSigned = !!participantSignature || !!representativeSignature;
    setIsSigned(isSigned);
    
    const orgSeal = await fetchOrganizationSeal();
    
    const trainerSig = await loadTrainerSignature();
    
    updateSignatureCache(
      participantSignature, 
      companySeal, 
      orgSeal, 
      trainerSig,
      representativeSignature
    );
    
    console.log('‚úÖ [LOAD] Chargement des signatures termin√©');
  } catch (error) {
    console.error('‚ùå [LOAD] Erreur lors du chargement des signatures:', error);
  }
}; 